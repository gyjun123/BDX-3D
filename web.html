<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½æ³•çº¿è´´å›¾ç”Ÿæˆä¸3Dè½¬æ¢ Pro (Terrain+ å·²æ›´æ–°)</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/exporters/STLExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/exporters/OBJExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/utils/BufferGeometryUtils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/modifiers/SimplifyModifier.js"></script>
    <!-- å¼•å…¥ UTIF.js ä»¥æ”¯æŒ TIFF æ ¼å¼ -->
    <script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow: hidden; /* é˜²æ­¢æ•´ä¸ªé¡µé¢æ»šåŠ¨ */
            height: 100vh;
            display: flex;
        }

        /* ä¾§è¾¹æ æ ·å¼ */
        .sidebar {
            width: 360px;
            background: rgba(30, 41, 59, 0.95);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            height: 100%;
            z-index: 10;
            transition: transform 0.3s ease;
            box-shadow: 5px 0 15px rgba(0,0,0,0.3);
        }

        .sidebar-header {
            padding: 20px;
            background: rgba(15, 23, 42, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .sidebar-header h1 {
            font-size: 1.2rem;
            color: #60a5fa;
            font-weight: 700;
        }
        
        .sidebar-header p {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-top: 5px;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        /* æ»šåŠ¨æ¡æ ·å¼ */
        .sidebar-content::-webkit-scrollbar { width: 6px; }
        .sidebar-content::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        .sidebar-content::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }

        /* æ§ä»¶ç»„ */
        .control-group {
            margin-bottom: 25px;
            background: rgba(255, 255, 255, 0.03);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .group-title {
            font-size: 0.9rem;
            color: #cbd5e1;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            font-weight: 600;
        }
        
        .group-title::before {
            content: '';
            display: block;
            width: 4px;
            height: 14px;
            background: #60a5fa;
            margin-right: 8px;
            border-radius: 2px;
        }

        /* ä¸Šä¼ åŒºåŸŸ */
        .upload-area {
            border: 2px dashed #475569;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 20px;
            background: rgba(30, 41, 59, 0.5);
        }

        .upload-area:hover {
            border-color: #60a5fa;
            background: rgba(96, 165, 250, 0.1);
        }

        .upload-icon { font-size: 24px; margin-bottom: 8px; }
        .upload-hint { font-size: 0.85rem; color: #94a3b8; }

        /* æ»‘å—å’Œè¾“å…¥æ¡† */
        .control-row { margin-bottom: 15px; }
        .control-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: #94a3b8;
            margin-bottom: 6px;
        }
        .value-display { color: #60a5fa; font-weight: bold; font-family: monospace; }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #334155;
            border-radius: 3px;
            -webkit-appearance: none;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #60a5fa;
            border-radius: 50%;
            transition: transform 0.1s;
        }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }

        select {
            width: 100%;
            padding: 8px;
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 6px;
            color: #e2e8f0;
            font-size: 0.9rem;
            outline: none;
        }

        /* 2Dé¢„è§ˆå°å›¾ */
        .mini-previews {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        .mini-preview-box {
            aspect-ratio: 1;
            background: #000;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            border: 1px solid #334155;
        }
        .mini-preview-box img { width: 100%; height: 100%; object-fit: cover; }
        .mini-tag {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.6);
            color: #fff;
            font-size: 0.7rem;
            padding: 2px 5px;
            text-align: center;
        }

        /* åº•éƒ¨æŒ‰é’®æ  */
        .sidebar-footer {
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(15, 23, 42, 0.8);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .btn {
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-size: 0.9rem;
        }

        .btn-primary {
            background: #60a5fa;
            color: #fff;
            grid-column: span 2;
        }
        .btn-primary:hover:not(:disabled) { background: #3b82f6; }
        .btn-secondary { background: #334155; color: #e2e8f0; }
        .btn-secondary:hover:not(:disabled) { background: #475569; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* ä¸»è§†å›¾åŒºåŸŸ */
        .main-viewport {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
        }
        
        #modelViewer { 
            width: 100%; 
            height: 100%; 
            /* ç™½è‰²åˆ°å¤©è“è‰²æ¸å˜èƒŒæ™¯ */
            background: radial-gradient(circle at center, #ffffff 0%, #bfdbfe 100%);
        }

        /* åŠ è½½é®ç½© */
        .loading-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(15, 23, 42, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
            display: none;
        }
        .spinner {
            width: 40px; height: 40px;
            border: 4px solid rgba(255,255,255,0.1);
            border-top-color: #60a5fa;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .toggle-sidebar {
            position: absolute;
            top: 20px; left: 20px;
            z-index: 20;
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            width: 40px; height: 40px;
            border-radius: 8px;
            cursor: pointer;
            display: none; /* é»˜è®¤åœ¨å¤§å±ä¸æ˜¾ç¤ºï¼Œå¯æ ¹æ®éœ€æ±‚å¼€å¯ */
            align-items: center;
            justify-content: center;
        }
        
        /* æ¨¡å¼åˆ‡æ¢æ ‡ç­¾é¡µ */
        .mode-tabs {
            display: flex;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 4px;
            margin-bottom: 20px;
        }
        
        .mode-tab {
            flex: 1;
            text-align: center;
            padding: 8px;
            font-size: 0.85rem;
            cursor: pointer;
            border-radius: 6px;
            color: #94a3b8;
            transition: all 0.2s;
        }
        
        .mode-tab.active {
            background: #60a5fa;
            color: white;
            font-weight: 600;
        }

        /* å“åº”å¼ */
        @media (max-width: 900px) {
            .sidebar { position: absolute; transform: translateX(0); }
            .sidebar.collapsed { transform: translateX(-100%); }
            .toggle-sidebar { display: flex; }
        }
        /* å…¨å±€æ‹–æ‹½é®ç½© */
        .drag-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(96, 165, 250, 0.3);
            border: 4px dashed #60a5fa;
            z-index: 200;
            pointer-events: none; /* è®©äº‹ä»¶ç©¿é€ï¼Œé¿å…é—ªçƒ */
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        /* Zè½´è°ƒèŠ‚æ† */
        .z-slider-container {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            height: 60%;
            background: rgba(30, 41, 59, 0.8);
            padding: 10px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 50;
        }
        
        .z-slider-track {
            flex: 1;
            width: 6px;
            background: #334155;
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }
        
        .z-slider-thumb {
            position: absolute;
            left: 50%;
            bottom: 0; /* é»˜è®¤ 0% */
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: #60a5fa;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .z-slider-thumb:active { cursor: grabbing; transform: translateX(-50%) scale(1.2); }
        
        .z-label {
            color: #60a5fa;
            font-weight: bold;
            font-size: 0.9rem;
            margin-bottom: 10px;
            font-family: monospace;
        }
        
        .z-icon {
            color: #94a3b8;
            font-size: 0.8rem;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="drag-overlay" id="dragOverlay">æ¾å¼€ä»¥ä¸Šä¼ å›¾åƒ</div>

    <!-- ä¾§è¾¹æ  -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <h1>æ™ºèƒ½æ³•çº¿è´´å›¾ç”Ÿæˆä¸3Dè½¬æ¢</h1>
            <p>ç»“æ„æ„ŸçŸ¥é‡å»º | æ¯›å‘ç»†èŠ‚å¢å¼ºç‰ˆ</p>
        </div>

        <div class="sidebar-content">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">ğŸ“·</div>
                <div>ç‚¹å‡»ä¸Šä¼  æˆ– Ctrl+V ç²˜è´´</div>
                <div class="upload-hint">æ”¯æŒ jpg, png, bmp, tiff ç­‰</div>
                <input type="file" id="fileInput" accept="image/*" style="display: none;">
            </div>

            <div class="mini-previews">
                <div class="mini-preview-box">
                    <img id="previewOriginal" src="" style="display:none">
                    <div class="mini-tag">åŸå›¾</div>
                </div>
                <div class="mini-preview-box">
                    <img id="previewNormal" src="" style="display:none">
                    <div class="mini-tag">ç»“æ„æ¢¯åº¦</div>
                </div>
            </div>

            <div class="control-group">
                <div class="group-title">1. ç»“æ„æ„ŸçŸ¥é‡å»º</div>
                
                <div class="control-row">
                    <div class="control-label">
                        <label>å»å™ªå¼ºåº¦ (æ¶ˆé™¤å°é˜¶)</label>
                        <span id="denoiseStrengthVal" class="value-display">6.0</span>
                    </div>
                    <input type="range" id="denoiseStrength" min="0" max="10" step="0.5" value="6.0">
                    <div style="font-size: 0.75rem; color: #64748b; margin-top: 4px;">æŠ¹å¹³å¾®å°çº¹ç†å’Œå°é˜¶ï¼Œç”Ÿæˆå…‰æ»‘æ›²é¢</div>
                </div>
                
                <div class="control-row">
                    <div class="control-label">
                        <label>ç»“æ„ä¿æŠ¤ (ä¿ç•™ç¡¬è¾¹)</label>
                        <span id="structureProtectVal" class="value-display">0.9</span>
                    </div>
                    <input type="range" id="structureProtect" min="0" max="1" step="0.05" value="0.9">
                    <div style="font-size: 0.75rem; color: #64748b; margin-top: 4px;">å€¼è¶Šé«˜ï¼Œå¤´å‘ã€è¡£ç‰©è¾¹ç¼˜ç­‰æ˜æ˜¾ç»“æ„è¶Šæ¸…æ™°</div>
                </div>
                
                <div class="control-row">
                    <div class="control-label">
                        <label>åŸå§‹ä¿çœŸåº¦ (å½¢çŠ¶æ ¡æ­£)</label>
                        <span id="fidelityVal" class="value-display">0.8</span>
                    </div>
                    <input type="range" id="fidelity" min="0" max="1" step="0.05" value="0.8">
                    <div style="font-size: 0.75rem; color: #64748b; margin-top: 4px;">å¹³è¡¡ï¼š0=å®Œå…¨å¹³æ»‘(å¯èƒ½å˜å½¢) <-> 1=å¿ å®åŸå›¾(å¯èƒ½å¸¦å°é˜¶)</div>
                </div>
                
                <div class="control-row" style="border-top: 1px dashed #475569; padding-top: 10px; margin-top: 10px;">
                    <div class="control-label">
                        <label>æ›²é¢æŠ›å…‰ (å»é™¤å¾®èµ·ä¼)</label>
                        <span id="surfacePolishVal" class="value-display">0.0</span>
                    </div>
                    <input type="range" id="surfacePolish" min="0" max="5" step="0.1" value="0.0">
                    <div style="font-size: 0.75rem; color: #64748b; margin-top: 4px;">å¼ºåŠ›æŠ¹å¹³å¤§é¢ç§¯å¹³ç¼“åŒºåŸŸçš„å™ªç‚¹ (0=å…³é—­)</div>
                </div>
                
                <div class="control-row">
                    <div class="control-label">
                        <label>å¹³å¦åº¦é˜ˆå€¼ (åˆ¤å®šæ ‡å‡†)</label>
                        <span id="flatnessThresholdVal" class="value-display">0.5</span>
                    </div>
                    <input type="range" id="flatnessThreshold" min="0.1" max="2.0" step="0.1" value="0.5">
                    <div style="font-size: 0.75rem; color: #64748b; margin-top: 4px;">å€¼è¶Šå¤§ï¼Œè¶Šé™¡å³­çš„é¢ä¹Ÿä¼šè¢«è§†ä¸ºå¹³å¦è€Œè¿›è¡ŒæŠ›å…‰</div>
                </div>

                <div class="control-row">
                    <div class="control-label">
                        <label>åº•æ¿å™ªç‚¹æ¶ˆé™¤ (mm)</label>
                        <span id="floorThresholdVal" class="value-display">0.05</span>
                    </div>
                    <input type="range" id="floorThreshold" min="0" max="0.5" step="0.01" value="0.05">
                    <div style="font-size: 0.75rem; color: #64748b; margin-top: 4px;">ä½äºæ­¤é«˜åº¦çš„åŒºåŸŸå°†è¢«å¼ºåˆ¶è®¾ä¸º 0 å¹³é¢</div>
                </div>
            </div>

            <div class="control-group">
                <div class="group-title">2. 3D å‡ ä½•å‚æ•°</div>
                <div class="control-row">
                    <div class="control-label">
                        <label>æ·±åº¦/é«˜åº¦ (Zè½´)</label>
                        <span id="depthScaleVal" class="value-display">3</span>
                    </div>
                    <input type="range" id="depthScale" min="1" max="200" step="1" value="3">
                </div>
                <div class="control-row">
                    <div class="control-label">
                        <label>æœ€å¤§åˆ†è¾¨ç‡é™åˆ¶</label>
                        <select id="maxResolution">
                            <option value="512">512 px (æé€Ÿ)</option>
                            <option value="800">800 px (æ¨è)</option>
                            <option value="1024">1024 px (æ¸…æ™°)</option>
                            <option value="2048">2048 px (é«˜è´¨é‡)</option>
                            <option value="0" selected>åŸå§‹å°ºå¯¸ (æ— æŸ)</option>
                        </select>
                        <div style="font-size: 0.75rem; color: #f59e0b; margin-top: 4px; display: none;" id="resWarning">æ³¨æ„ï¼šåŸå§‹å°ºå¯¸å¯èƒ½ä¼šå¯¼è‡´å¤§å›¾ç”Ÿæˆç¼“æ…¢</div>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <div class="group-title">3. æ˜¾ç¤ºè®¾ç½®</div>
                <div class="control-row">
                    <div class="control-label"><label>æè´¨æ¨¡å¼</label></div>
                    <select id="materialMode">
                        <option value="terrain" selected>åœ°å½¢ä¼ªå½© (æ¨è)</option>
                        <option value="pbr_clay">é«˜ç²¾æ³¥å¡‘ (PBR Clay)</option>
                        <option value="pbr_metal">é‡‘å±è´¨æ„Ÿ (PBR Metal)</option>
                        <option value="phong">æ ‡å‡†å…‰ç…§ (Phong)</option>
                        <option value="normal">æ³•çº¿è‰²å½©</option>
                        <option value="wireframe">ç½‘æ ¼çº¿æ¡†</option>
                    </select>
                </div>
                <div class="control-row">
                    <div class="control-label">
                         <label for="showGrid">æ˜¾ç¤ºåœ°æ¿ç½‘æ ¼</label>
                         <input type="checkbox" id="showGrid">
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-label">
                         <label for="enableShadows">å¼€å¯æŠ•å½± (Shadows)</label>
                         <input type="checkbox" id="enableShadows">
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <div class="group-title">6. åœ°å½¢å¢å¼º (Terrain+)</div>
                <div class="control-row">
                    <div class="control-label">
                         <label for="overlayTexture">å åŠ åŸå›¾çº¹ç†</label>
                         <input type="checkbox" id="overlayTexture">
                    </div>
                    <div style="font-size: 0.75rem; color: #64748b; margin-top: 4px;">å°†åŸå§‹ç…§ç‰‡è´´åœ¨æ¨¡å‹è¡¨é¢ï¼Œå¢åŠ ç»†èŠ‚</div>
                </div>
                <div class="control-row">
                    <div class="control-label">
                         <label for="hydroEffect">æ™ºèƒ½æ°´ä½“å…‰æ³½</label>
                         <input type="checkbox" id="hydroEffect">
                    </div>
                    <div style="font-size: 0.75rem; color: #64748b; margin-top: 4px;">ä½æ´¼å¤„è‡ªåŠ¨å˜æ¹¿æ¶¦/åå…‰ï¼Œé«˜å¤„å˜ç²—ç³™</div>
                </div>
            </div>
            <div class="control-group">
                <div class="group-title">4. ç½‘æ ¼ä¼˜åŒ–</div>
                <div class="control-row">
                    <div class="control-label"><label>ç²¾åº¦</label></div>
                    <select id="optPrecision">
                        <option value="0.01">0.01 (é«˜å‹ç¼©)</option>
                        <option value="0.005">0.005 (ä¸­ç­‰)</option>
                        <option value="0.001">0.001 (æ¨è)</option>
                        <option value="0.0001" selected>0.0001 (é«˜ä¿çœŸ)</option>
                    </select>
                </div>
                <div class="control-row">
                    <div class="control-label" style="justify-content: flex-start; gap: 10px;">
                        <input type="checkbox" id="optDeleteZero" style="width: auto;">
                        <label for="optDeleteZero">åˆ é™¤é›¶å¹³é¢å¤šè¾¹å½¢</label>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-label" style="justify-content: flex-start; gap: 10px;">
                        <input type="checkbox" id="optBorder" checked style="width: auto;">
                        <label for="optBorder">ä¼˜åŒ–è¾¹ç•Œ</label>
                    </div>
                </div>
                <div class="control-row">
                    <div class="control-label" style="justify-content: flex-start; gap: 10px;">
                        <input type="checkbox" id="optAdaptive" checked style="width: auto;">
                        <label for="optAdaptive">è‡ªé€‚åº”ç¨€ç–åŒ–</label>
                    </div>
                </div>
                <button class="btn btn-secondary" id="startOptBtn" style="width: 100%; margin-top: 10px;">å¼€å§‹ä¼˜åŒ–</button>
                <div style="margin-top: 10px; font-size: 0.8rem; color: #94a3b8;">
                    ä¼˜åŒ–åé¢æ•°: <span id="optFaceCount" class="value-display">-</span>
                </div>
            </div>
            <div class="control-group">
                <div class="group-title">5. ç¯å¢ƒä¸å…‰ç…§ (å®æ—¶)</div>
                <div class="control-row">
                    <div class="control-label">
                        <label>ä¸»å…‰å¼ºåº¦</label>
                        <span id="dirLightVal" class="value-display">1.2</span>
                    </div>
                    <input type="range" id="dirLightIntensity" min="0" max="3" step="0.1" value="1.2">
                </div>
                <div class="control-row">
                    <div class="control-label">
                        <label>ç¯å¢ƒå…‰å¼ºåº¦</label>
                        <span id="ambLightVal" class="value-display">0.1</span>
                    </div>
                    <input type="range" id="ambLightIntensity" min="0" max="2" step="0.1" value="0.1">
                </div>
                <div class="control-row">
                    <div class="control-label">
                        <label>è‰²å½©å¯¹æ¯”åº¦ (Gamma)</label>
                        <span id="gammaVal" class="value-display">1.0</span>
                    </div>
                    <input type="range" id="sceneGamma" min="0.5" max="2.5" step="0.1" value="1.0">
                </div>
                <div class="control-row">
                    <div class="control-label">
                        <label>æè´¨é«˜å…‰ (åå…‰åº¦)</label>
                        <span id="shininessVal" class="value-display">5</span>
                    </div>
                    <input type="range" id="matShininess" min="0" max="100" step="1" value="5">
                </div>
                
                <div class="control-row" style="margin-top:15px; border-top:1px solid #334155; padding-top:10px;">
                    <div class="control-label"><label>åœ°å½¢é¢œè‰²æ˜ å°„</label></div>
                    <div id="colorStopsContainer" style="display:flex; flex-direction:column; gap:5px; margin-bottom:10px;">
                        <!-- åŠ¨æ€ç”Ÿæˆçš„é¢œè‰²æ¡ç›® -->
                    </div>
                    <div style="display:flex; gap:5px;">
                        <button class="btn btn-secondary" id="resetColorsBtn" style="flex:1; font-size:0.8rem;">é‡ç½®é»˜è®¤</button>
                        <button class="btn btn-primary" id="applyColorsBtn" style="flex:1; font-size:0.8rem;">åº”ç”¨é¢œè‰²</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar-footer">
            <button class="btn btn-primary" id="generateBtn" disabled>âš¡ ç”Ÿæˆ 3D æ¨¡å‹</button>
            <button class="btn btn-secondary" id="exportSTLBtn" disabled>ğŸ“¦ å¯¼å‡º STL</button>
            <button class="btn btn-secondary" id="exportOBJBtn" disabled>ğŸ’¾ å¯¼å‡º OBJ</button>
        </div>
    </div>

    <!-- 3D è§†çª— -->
    <div class="main-viewport">
        <div class="toggle-sidebar" id="toggleSidebar">â˜°</div>
        <div id="modelViewer"></div>
        
        <!-- Zè½´è°ƒèŠ‚æ† -->
        <div class="z-slider-container" id="zSliderContainer" style="display:none;">
            <div class="z-label" id="zSliderVal">3mm</div>
            <div class="z-slider-track" id="zSliderTrack">
                <div class="z-slider-thumb" id="zSliderThumb"></div>
            </div>
            <div class="z-icon">Height</div>
        </div>

        <div class="loading-overlay" id="loadingOverlay">
            <div class="spinner"></div>
            <div id="loadingText">å¤„ç†ä¸­...</div>
        </div>
    </div>

    <script>
        // ================= å…¨å±€å˜é‡ =================
        let scene, camera, renderer, controls;
        let currentMesh = null;
        let gridHelper = null;
        let originalImageData = null; 
        let baseGeometry = null; // å­˜å‚¨æœªç¼©æ”¾ Z çš„åŸºç¡€å‡ ä½•ä½“
        let currentNormalTexture = null; // å…¨å±€å­˜å‚¨æ³•çº¿è´´å›¾
        let currentDiffuseTexture = null; // å…¨å±€å­˜å‚¨åŸå›¾çº¹ç†
        let currentRoughnessTexture = null; // å…¨å±€å­˜å‚¨ç²—ç³™åº¦è´´å›¾
        
        // å…‰ç…§å¯¹è±¡å¼•ç”¨
        let g_ambientLight, g_dirLight, g_fillLight, g_backLight;
        
        // é¢œè‰²é…ç½®
        let terrainStops = [
            {p: 0.00, c: "#2f7a86"},
            {p: 0.08, c: "#4c7e87"},
            {p: 0.17, c: "#6a8289"},
            {p: 0.25, c: "#7a868b"},
            {p: 0.33, c: "#367853"},
            {p: 0.42, c: "#537f66"},
            {p: 0.50, c: "#598d54"},
            {p: 0.58, c: "#748f72"},
            {p: 0.67, c: "#907c72"},
            {p: 0.75, c: "#917363"},
            {p: 0.83, c: "#916a55"},
            {p: 0.92, c: "#916146"},
            {p: 0.99, c: "#848484"}
        ];
        
        // ================= åˆå§‹åŒ– =================
        function init() {
            initScene();
            initEvents();
            renderColorStops(); // åˆå§‹åŒ–é¢œè‰²ç¼–è¾‘å™¨
        }

        function initScene() {
            const container = document.getElementById('modelViewer');
            scene = new THREE.Scene();
            // scene.background = new THREE.Color(0x111827); 
            scene.background = null; // è®¾ç½®ä¸º null ä»¥æ˜¾ç¤º CSS æ¸å˜èƒŒæ™¯

            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 10000);
            camera.position.set(0, -200, 200);

            // å¿…é¡»å¼€å¯ alpha: true æ‰èƒ½é€å‡º CSS èƒŒæ™¯
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // æŸ”å’Œé˜´å½±
            
            // å¼€å¯ LinearToneMapping ä»¥æ”¯æŒ Exposure è°ƒèŠ‚ (å¯¹æ¯”åº¦æ»‘å—)
            renderer.outputEncoding = THREE.LinearEncoding;
            renderer.toneMapping = THREE.LinearToneMapping;
            renderer.toneMappingExposure = 1.0;
            
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            g_ambientLight = new THREE.AmbientLight(0xffffff, 0.1); 
            scene.add(g_ambientLight);

            g_dirLight = new THREE.DirectionalLight(0xffffff, 1.5); 
            g_dirLight.position.set(100, 150, 100);
            g_dirLight.castShadow = false; // é»˜è®¤å…³é—­ï¼Œç”±å¤é€‰æ¡†æ§åˆ¶
            
            // ä¼˜åŒ–é˜´å½±é…ç½®
            g_dirLight.shadow.mapSize.width = 2048;
            g_dirLight.shadow.mapSize.height = 2048;
            g_dirLight.shadow.camera.near = 0.5;
            g_dirLight.shadow.camera.far = 1000;
            g_dirLight.shadow.camera.left = -150;
            g_dirLight.shadow.camera.right = 150;
            g_dirLight.shadow.camera.top = 150;
            g_dirLight.shadow.camera.bottom = -150;
            g_dirLight.shadow.bias = -0.0005;
            
            scene.add(g_dirLight);

            g_fillLight = new THREE.DirectionalLight(0xcceeff, 0.5);
            g_fillLight.position.set(-100, 50, 50);
            scene.add(g_fillLight);

            g_backLight = new THREE.DirectionalLight(0x445566, 0.3);
            g_backLight.position.set(0, -100, -50);
            scene.add(g_backLight);

            gridHelper = new THREE.GridHelper(500, 20, 0x334155, 0x1e293b);
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.visible = false; 
            scene.add(gridHelper);

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function onWindowResize() {
            const container = document.getElementById('modelViewer');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // ================= æ ¸å¿ƒç®—æ³•ï¼šç»“æ„æ„ŸçŸ¥æ¢¯åº¦åœºç§¯åˆ† (Data Fidelity) =================

        // 1. è®¡ç®—åŸå§‹æ¢¯åº¦åœº (å‡çº§ä¸º Sobel ç®—å­ä»¥è·å¾—æ›´å¹³æ»‘ä¸”æŠ—å™ªçš„æ¢¯åº¦)
        function computeGradients(data, width, height) {
            const Gx = new Float32Array(width * height);
            const Gy = new Float32Array(width * height);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    
                    if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {
                        const val = data[idx * 4];
                        const left = x > 0 ? data[(idx - 1) * 4] : val;
                        const right = x < width - 1 ? data[(idx + 1) * 4] : val;
                        const top = y > 0 ? data[(idx - width) * 4] : val;
                        const bottom = y < height - 1 ? data[(idx + width) * 4] : val;
                        Gx[idx] = (right - left) * 0.5;
                        Gy[idx] = (bottom - top) * 0.5;
                        continue;
                    }
                    
                    const tl = data[((y-1)*width + (x-1))*4];
                    const t  = data[((y-1)*width + x)*4];
                    const tr = data[((y-1)*width + (x+1))*4];
                    
                    const l  = data[(y*width + (x-1))*4];
                    const r  = data[(y*width + (x+1))*4];
                    
                    const bl = data[((y+1)*width + (x-1))*4];
                    const b  = data[((y+1)*width + x)*4];
                    const br = data[((y+1)*width + (x+1))*4];
                    
                    const gx = (tr + 2*r + br) - (tl + 2*l + bl);
                    const gy = (bl + 2*b + br) - (tl + 2*t + tr);
                    
                    Gx[idx] = gx / 8.0;
                    Gy[idx] = gy / 8.0;
                }
            }
            return { Gx, Gy };
        }

        // 2. è®¡ç®—è¾¹ç¼˜ä¿æŠ¤é®ç½© (åŸºäº Sobel + Hessian Ridge Detection)
        // å‡çº§ç‰ˆï¼šåŠ å…¥ Hessian çŸ©é˜µç‰¹å¾å€¼æ£€æµ‹ï¼Œä¸“é—¨ç”¨äºæ•è·å‘ä¸ã€ç»†çº¿ç­‰è„ŠçŠ¶ç»“æ„
        function computeEdgeMask(Gx, Gy, data, width, height, structureProtect) {
            const mask = new Float32Array(width * height);
            const mag = new Float32Array(width * height);
            
            // 1. è®¡ç®—åŸºç¡€æ¢¯åº¦æ¨¡é•¿
            for(let i=0; i<width*height; i++) {
                mag[i] = Math.sqrt(Gx[i]*Gx[i] + Gy[i]*Gy[i]);
            }
            
            // 2. åŸºç¡€æ¢¯åº¦é˜ˆå€¼åˆ¤å®š
            const threshold = (1.1 - structureProtect) * 25.0; 
            
            for(let i=0; i<width*height; i++) {
                if(mag[i] > threshold) {
                    mask[i] = 1.0;
                } else if(mag[i] > threshold * 0.5) {
                    mask[i] = (mag[i] - threshold * 0.5) / (threshold * 0.5);
                } else {
                    mask[i] = 0.0;
                }
            }
            
            // 3. å¤šå°ºåº¦ Hessian + é«˜é¢‘å¯†åº¦æ£€æµ‹ (Multi-scale Hessian & Density)
            // ç›®çš„ï¼šåŒæ—¶ä¿æŠ¤ç»†å‘ä¸(Small Scale)ã€ç²—å‘ä¸(Large Scale)å’Œæˆç‰‡çº¹ç†(Density)
            
            const ridgeMap = new Float32Array(width * height);
            const densityMap = new Float32Array(width * height);
            
            // è¾…åŠ©å‡½æ•°ï¼šè·å–ç°åº¦å€¼
            const getVal = (x, y) => {
                if(x < 0) x = 0; if(x >= width) x = width - 1;
                if(y < 0) y = 0; if(y >= height) y = height - 1;
                const idx = (y * width + x) * 4;
                return data[idx] * 0.299 + data[idx+1] * 0.587 + data[idx+2] * 0.114;
            };

            // æ­¥éª¤ A: è®¡ç®— Hessian å“åº” (å¤šå°ºåº¦)
            // æˆ‘ä»¬åœ¨åŒä¸€ä¸ªå¾ªç¯ä¸­è®¡ç®—ä¸¤ä¸ªå°ºåº¦çš„å“åº”ï¼Œå–æœ€å¤§å€¼
            for(let y=0; y<height; y++) {
                for(let x=0; x<width; x++) {
                    let maxResponse = 0;
                    
                    // å®šä¹‰ä¸¤ä¸ªå°ºåº¦ï¼šstep=2 (ç»†å‘ä¸), step=4 (ç²—å‘ä¸/æˆç‰‡)
                    const scales = [2, 4];
                    
                    for(let k=0; k<scales.length; k++) {
                        const step = scales[k];
                        const val = getVal(x, y);
                        const val_l = getVal(x-step, y);
                        const val_r = getVal(x+step, y);
                        const val_u = getVal(x, y-step);
                        const val_d = getVal(x, y+step);
                        
                        // äºŒé˜¶å¯¼æ•° (å½’ä¸€åŒ–åˆ°åƒç´ å•ä½ï¼Œä»¥ä¾¿ä¸åŒå°ºåº¦å¯æ¯”)
                        const norm = step * 1.5;
                        
                        const Dxx = (val_r - 2*val + val_l) / norm;
                        const Dyy = (val_d - 2*val + val_u) / norm;
                        
                        const val_ur = getVal(x+step, y-step);
                        const val_ul = getVal(x-step, y-step);
                        const val_dr = getVal(x+step, y+step);
                        const val_dl = getVal(x-step, y+step);
                        
                        const Dxy = (val_dr - val_dl - val_ur + val_ul) / (4.0 * norm);
                        
                        const T = Dxx + Dyy;
                        const D = Dxx*Dyy - Dxy*Dxy;
                        const temp = Math.sqrt(Math.max(0, T*T - 4*D));
                        
                        const l1 = (T + temp) / 2;
                        const l2 = (T - temp) / 2;
                        
                        const absL1 = Math.abs(l1);
                        const absL2 = Math.abs(l2);
                        const maxL = Math.max(absL1, absL2);
                        const minL = Math.min(absL1, absL2);
                        
                        // çº¿æ€§åº¦å› å­ (Scale-Adaptive Linearity)
                        let linearity;
                        if (step === 2) {
                            // å°å°ºåº¦ (Step 2): ä¸¥æ ¼çº¿æ€§åº¦ï¼Œå¼ºåŠ›æŠ‘åˆ¶å™ªç‚¹
                            linearity = (maxL - minL) / (maxL + 0.1);
                        } else {
                            // å¤§å°ºåº¦ (Step 4): å®½æ¾çº¿æ€§åº¦ï¼Œå…è®¸å¼¯æ›²çš„ç²—å‘ä¸
                            // ç²—çº¿æ¡åœ¨å¼¯æ›²å¤„ minL å¯èƒ½ä¸ä¸º 0ï¼Œéœ€è¦æ›´å®½å®¹çš„åˆ¤å®š
                            const rawLin = (maxL - minL) / (maxL + 0.01);
                            linearity = Math.sqrt(rawLin); // å¼€æ ¹å·æå‡ä¸­é—´å€¼ (e.g. 0.5 -> 0.7)
                        }
                        
                        // å“åº”å€¼
                        // ä¿®æ­£ï¼šv10ç‰ˆé—ç•™é—®é¢˜ï¼ŒåŸé€»è¾‘åªè€ƒè™‘çº¿æ€§åº¦ï¼Œå¯¹äºéçº¯é»‘ä½†ä½å¯¹æ¯”åº¦åŒºåŸŸï¼ˆå¦‚æš—è‰²é©¬èº«ï¼‰ä¼šè¯¯åˆ¤ä¸ºå™ªç‚¹ã€‚
                        // ç°å¢åŠ å¯¹åŸå§‹å¼ºåº¦çš„è€ƒé‡ï¼šå¦‚æœ maxL è¶³å¤Ÿå¤§ï¼ˆå¼ºç»“æ„ï¼‰ï¼Œå³ä½¿çº¿æ€§åº¦ç¨å·®ä¹Ÿä¿ç•™ã€‚
                        // let response = maxL * linearity;
                        
                        // [å›æ»šå¹¶ä¼˜åŒ–] é‡æ–°å®¡è§† Hessian å“åº”è®¡ç®—
                        // ä¹‹å‰çš„ linearity è®¡ç®—å¯¹äºå¹³æ»‘æ›²é¢ï¼ˆç™½é©¬è‚šå­ï¼‰å¤ªè‹›åˆ»äº†ã€‚
                        // å¦‚æœ maxLï¼ˆä¸»æ›²ç‡ï¼‰æœ¬èº«å°±å¾ˆå¤§ï¼Œè¯´æ˜è¿™é‡Œç»å¯¹æœ‰ç»“æ„ï¼Œä¸éœ€è¦çœ‹çº¿æ€§åº¦ã€‚
                        // çº¿æ€§åº¦åªæ˜¯ç”¨æ¥åŒºåˆ†â€œæ‚ä¹±å™ªç‚¹â€å’Œâ€œæœ‰åºçº¿æ¡â€çš„ã€‚
                        
                        let response = 0;
                        
                        // ç­–ç•¥1ï¼šå¦‚æœç»“æ„å¼ºåº¦æé«˜ (maxL > 5)ï¼Œç›´æ¥ä¿¡ä»»å®ƒï¼Œæ— è§†çº¿æ€§åº¦
                        if (maxL > 5.0) {
                            response = maxL;
                        } 
                        // ç­–ç•¥2ï¼šå¦‚æœç»“æ„å¼ºåº¦ä¸­ç­‰ (maxL > 2)ï¼Œç¨å¾®çœ‹ä¸€ç‚¹çº¿æ€§åº¦ï¼Œä½†å¾ˆå®½å®¹
                        else if (maxL > 2.0) {
                            response = maxL * (0.5 + 0.5 * linearity); 
                        }
                        // ç­–ç•¥3ï¼šå¦‚æœç»“æ„å¼ºåº¦å¾ˆå¼± (maxL <= 2)ï¼Œè¿™å¯èƒ½æ˜¯å™ªç‚¹ï¼Œå¿…é¡»ä¸¥æ ¼æ£€æŸ¥çº¿æ€§åº¦
                        else {
                            response = maxL * linearity;
                        }
                        
                        // è¡¥ä¸å‡çº§ï¼šå…¨æ–¹ä½ç»“æ„ä¿æŠ¤
                        // 1. å¯¹äºéå¾®å°å°ºåº¦çš„å¼ºç»“æ„ï¼ˆå³ä½¿æœ‰ç‚¹å¼¯ï¼‰ï¼Œåªè¦å¼ºåº¦å¤Ÿå¤§ï¼Œå¼ºåˆ¶ä¿æŠ¤
                        // (ä¸Šé¢çš„ç­–ç•¥1å·²ç»è¦†ç›–äº†è¿™é‡Œï¼Œæ‰€ä»¥è¿™éƒ¨åˆ†å¯ä»¥ç®€åŒ–)
                        
                        // 2. [æ–°å¢] é’ˆå¯¹æš—éƒ¨å¹³æ»‘åŒºåŸŸçš„â€œä½é¢‘ä¿æŠ¤â€
                        // å¦‚æœæ˜¯å¤§å°ºåº¦(Step=4)ä¸”å¼ºåº¦é€‚ä¸­(>2.0)ï¼Œå³ä½¿çº¿æ€§åº¦å¾ˆå·®(æ˜¯å¹³æ»‘æ›²é¢è€Œéçº¿æ¡)ï¼Œä¹Ÿç»™äºˆåŸºç¡€ä¿æŠ¤
                        if (step === 4 && maxL > 2.0) {
                            response = Math.max(response, maxL * 0.4);
                        }

                        // 3. [ç´§æ€¥è¡¥æ•‘] äº®éƒ¨åŒºåŸŸä¿æŠ¤
                        // å¦‚æœåƒç´ æœ¬èº«å¾ˆäº®ï¼ˆval > 50ï¼‰ï¼Œè¯´æ˜å®ƒä¸å¯èƒ½æ˜¯èƒŒæ™¯ï¼Œå¿…é¡»ä¿ç•™èµ·ä¼
                        // è§£å†³â€œç™½é©¬å˜å¹³é¢â€çš„é—®é¢˜ï¼šç™½é©¬è™½ç„¶äº®ï¼Œä½†å†…éƒ¨ç»†èŠ‚å¯¹æ¯”åº¦ä½(maxLå°)ï¼Œå®¹æ˜“è¢«å½“åšå¹³å¦åŒºåŸŸæŠ¹å¹³ã€‚
                        if (val > 50.0 && maxL > 1.0) {
                            // åªè¦æœ‰ä¸€ç‚¹ç‚¹èµ·ä¼(maxL > 1.0)ï¼Œä¸”æœ¬èº«æ˜¯äº®è‰²ç‰©ä½“ï¼Œå°±ç»™äºˆæœ€ä½é™åº¦çš„ä¿æŠ¤
                            response = Math.max(response, 0.5); 
                        }
                        
                        // 4. [æ–°å¢] é’ˆå¯¹æ·±è‰²å¹³æ»‘èƒŒæ™¯ä¸Šçš„æ ‘å¹²/æ†å­ä¿æŠ¤ (Linearity Rescue)
                        // æ ‘å¹²æ˜¯ç›´çš„(linearityé«˜)ï¼Œä½†å¯èƒ½å¾ˆæš—(maxLä½)ï¼Œä¸”å¯èƒ½ä¸åœ¨äº®éƒ¨(val < 50)ã€‚
                        // å¦‚æœçº¿æ€§åº¦éå¸¸é«˜(>0.8)ï¼Œè¯´æ˜å®ƒæ˜¯äººé€ ç‰©æˆ–è‡ªç„¶ç•Œçš„é•¿æ¡ç‰©ä½“ï¼Œå³ä½¿å¾ˆæš—ä¹Ÿå¿…é¡»ä¿æŠ¤ã€‚
                        if (linearity > 0.8 && maxL > 1.0) {
                             response = Math.max(response, maxL * 0.8);
                        }
                        
                        if(response > maxResponse) maxResponse = response;
                    }
                    
                    const ridgeThreshold = (1.0 - structureProtect) * 3.0 + 0.5; 
                    
                    if (maxResponse > ridgeThreshold) {
                        let strength = (maxResponse - ridgeThreshold) / 5.0;
                        if(strength > 1.0) strength = 1.0;
                        ridgeMap[y*width+x] = strength;
                    }
                }
            }
            
            // æ­¥éª¤ B: æ¢å¤é«˜é¢‘çº¹ç†å¯†åº¦æ£€æµ‹ (Density Map)
            // è§£å†³â€œæˆç‰‡æ¯›å‘è¢«æŠ¹å¹³â€çš„é—®é¢˜
            // ä¿®æ­£ï¼šv10ç‰ˆé—ç•™é—®é¢˜ï¼ŒåŸé˜ˆå€¼ 5.0 è¿‡é«˜ï¼Œå¯¼è‡´å¼±çº¹ç†è¢«å¿½ç•¥ã€‚ç°é™ä¸º 2.0
            const r = 3; 
            for(let y=0; y<height; y++) {
                for(let x=0; x<width; x++) {
                    let count = 0;
                    // å¿«é€Ÿé‡‡æ ·
                    for(let dy=-r; dy<=r; dy++) {
                        for(let dx=-r; dx<=r; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if(nx>=0 && nx<width && ny>=0 && ny<height) {
                                // åªè¦æ¢¯åº¦ > 2.0 (é™ä½é˜ˆå€¼ä»¥æ•è·æ›´å¤šç»†èŠ‚)ï¼Œå°±ç®—ä½œçº¹ç†ç‚¹
                                if(mag[ny*width+nx] > 2.0) count++;
                            }
                        }
                    }
                    // 49ä¸ªç‚¹é‡Œå¦‚æœæœ‰ 15 ä¸ªä»¥ä¸Šæ˜¯çº¹ç†ç‚¹ (çº¦30%)ï¼Œè¯´æ˜æ˜¯å¯†é›†åŒº
                    if(count > 15) {
                        // è®¡ç®—å¯†åº¦å¼ºåº¦
                        const dens = (count - 15) / 20.0; 
                        densityMap[y*width+x] = dens;
                    }
                }
            }
            
            // 4. åˆå¹¶ Maskï¼šæ¢¯åº¦è¾¹ç¼˜ OR Hessianè„Šçº¿ OR å¯†åº¦åŒº
            for(let i=0; i<width*height; i++) {
                // å–æœ€å¤§å€¼
                // æ³¨æ„ï¼šdensityMap ç»™äºˆ 0.7 çš„æƒé‡ï¼Œé¿å…å¹³å¦åŒºçš„å™ªç‚¹èšé›†è¢«è¿‡åº¦ä¿æŠ¤
                mask[i] = Math.max(mask[i], ridgeMap[i], densityMap[i] * 0.7);
            }
            
            // 5. è†¨èƒ€ (Dilation) ä»¥ä¿æŠ¤è¾¹ç¼˜é™„è¿‘çš„åŒºåŸŸ
            // ä¿®æ­£ï¼šå¢åŠ è†¨èƒ€åŠå¾„ï¼Œç¡®ä¿åƒæ ‘å¹²è¿™ç§ç»†é•¿ç»“æ„çš„è¾¹ç¼˜èƒ½å®Œå…¨è¦†ç›–ä¸»ä½“
            const dilatedMask = new Float32Array(width * height);
            const dilationRadius = 2; // ä» 1 å¢åŠ åˆ° 2
            
            for(let y=0; y<height; y++) {
                for(let x=0; x<width; x++) {
                    let maxVal = 0;
                    for(let dy=-dilationRadius; dy<=dilationRadius; dy++) {
                        for(let dx=-dilationRadius; dx<=dilationRadius; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if(nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                const val = mask[ny * width + nx];
                                if(val > maxVal) maxVal = val;
                            }
                        }
                    }
                    dilatedMask[y * width + x] = maxVal;
                }
            }
            
            return dilatedMask;
        }

        // 3. è‡ªé€‚åº”ç»“æ„å¹³æ»‘
        function adaptiveSmoothGradient(Gx, Gy, width, height, denoiseStrength, edgeMask) {
            if (denoiseStrength <= 0) return { Gx, Gy };

            const newGx = new Float32Array(Gx.length);
            const newGy = new Float32Array(Gy.length);
            
            // åœ¨éè¾¹ç¼˜åŒºåŸŸä½¿ç”¨æå¤§çš„æ¨¡ç³ŠåŠå¾„
            // åœ¨è¾¹ç¼˜åŒºåŸŸä½¿ç”¨æå°çš„æ¨¡ç³ŠåŠå¾„ (æˆ–è€…ä¸æ¨¡ç³Š)
            
            const maxRadius = Math.ceil(denoiseStrength);
            const sigma = denoiseStrength;
            
            // é¢„è®¡ç®—é«˜æ–¯æ ¸
            const weights = [];
            let totalW = 0;
            for (let dy = -maxRadius; dy <= maxRadius; dy++) {
                for (let dx = -maxRadius; dx <= maxRadius; dx++) {
                    const distSq = dx*dx + dy*dy;
                    if (distSq > maxRadius*maxRadius) continue;
                    const w = Math.exp(-distSq / (2 * sigma * sigma));
                    weights.push({dx, dy, w});
                    totalW += w;
                }
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const protect = edgeMask[idx]; // 0..1
                    
                    // å¦‚æœæ˜¯å¼ºè¾¹ç¼˜ (protect > 0.8)ï¼Œç›´æ¥ä¿ç•™åŸå€¼ï¼Œæˆ–è€…ä»…åšå¾®å°æ¨¡ç³Š
                    if (protect > 0.8) {
                        newGx[idx] = Gx[idx];
                        newGy[idx] = Gy[idx];
                        continue;
                    }
                    
                    let sumGx = 0, sumGy = 0, sumW = 0;
                    
                    for (let k = 0; k < weights.length; k++) {
                        const {dx, dy, w} = weights[k];
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const nIdx = ny * width + nx;
                            sumGx += Gx[nIdx] * w;
                            sumGy += Gy[nIdx] * w;
                            sumW += w;
                        }
                    }
                    
                    const smoothedGx = sumGx / sumW;
                    const smoothedGy = sumGy / sumW;

                    // æ··åˆï¼šprotect è¶Šå¤§ï¼Œè¶Šæ¥è¿‘åŸå€¼
                    newGx[idx] = smoothedGx * (1 - protect) + Gx[idx] * protect;
                    newGy[idx] = smoothedGy * (1 - protect) + Gy[idx] * protect;
                }
            }
            
            return { Gx: newGx, Gy: newGy };
        }

        // 4. æ³Šæ¾æ±‚è§£å™¨ (å¼•å…¥æ•°æ®é¡¹çº¦æŸ)
        async function solvePoissonWithFidelity(Gx, Gy, originalData, width, height, fidelity, edgeMask, iterations = 100) {
            const H = new Float32Array(width * height);
            const div = new Float32Array(width * height);
            const H0 = new Float32Array(width * height); 
            
            // é¢„å¤„ç†åŸå§‹é«˜åº¦ (ä¿æŒ 0-255 æ ‡åº¦ï¼Œä¸æ¢¯åº¦åœºä¸€è‡´)
            for(let i=0; i<width*height; i++) {
                H0[i] = originalData[i*4]; 
                H[i] = H0[i]; // ä»¥åŸå›¾ä¸ºåˆå§‹çŒœæµ‹ï¼ŒåŠ é€Ÿæ”¶æ•›
            }

            // [æ ¸å¿ƒä¿®æ­£] åŠ¨æ€èƒŒæ™¯é˜ˆå€¼ (Dynamic Background Threshold)
            // åŸç†ï¼šä¸ä½¿ç”¨å›ºå®šçš„ bgThreshold (1 æˆ– 10)ï¼Œè€Œæ˜¯ç»Ÿè®¡å…¨å›¾çš„æš—éƒ¨ç‰¹å¾ã€‚
            // å¦‚æœå›¾ä¸­æœ‰å¤§é‡ 0-5 ä¹‹é—´çš„æš—éƒ¨åƒç´ ï¼ˆå¦‚é»‘é©¬ï¼‰ï¼Œè¯´æ˜è¿™æ˜¯ç‰©ä½“æœ¬èº«ï¼Œä¸èƒ½ä½œä¸ºèƒŒæ™¯æŠ¹å¹³ã€‚
            // åªæœ‰å½“æš—éƒ¨åƒç´ æå°‘ä¸”ç¦»æ•£æ—¶ï¼Œæ‰è®¤ä¸ºæ˜¯çœŸæ­£çš„èƒŒæ™¯ã€‚
            
            // 1. ç»Ÿè®¡æš—éƒ¨ç›´æ–¹å›¾
            let darkPixelCount = 0;
            for(let i=0; i<width*height; i++) {
                if(H0[i] < 5) darkPixelCount++;
            }
            
            // 2. åˆ¤å®šï¼šå¦‚æœæš—éƒ¨å æ¯”è¶…è¿‡ 5% (ä¾‹å¦‚é»‘é©¬)ï¼Œåˆ™ç¦ç”¨èƒŒæ™¯å¼ºåˆ¶æŠ¹å¹³ï¼Œæˆ–è€…ä½¿ç”¨æä½çš„é˜ˆå€¼(0.1)
            // å¦åˆ™ï¼ˆç™½åº•å›¾/ç°åº•å›¾ï¼‰ï¼Œä¿æŒæ­£å¸¸é˜ˆå€¼ä»¥å»é™¤åº•å™ª
            let effectiveBgThreshold = 1.0;
            const darkRatio = darkPixelCount / (width * height);
            
            // ä¿®æ­£ï¼šv10ç‰ˆé—ç•™é—®é¢˜ï¼ŒåŸé€»è¾‘å¯¹äºâ€œé»‘èƒŒæ™¯ä¸‹çš„äº®ä¸»ä½“â€å¯èƒ½ä¼šè¯¯åˆ¤ã€‚
            // ç°å¢åŠ â€œè¾¹ç¼˜æ£€æµ‹â€è¾…åŠ©åˆ¤æ–­ï¼šå¦‚æœæš—éƒ¨å¾ˆå¤šï¼Œä¸”å¤§éƒ¨åˆ†æš—éƒ¨éƒ½åœ¨è¾¹ç¼˜åŒºåŸŸï¼ˆè¯´æ˜æ˜¯é»‘èƒŒæ™¯ï¼‰ï¼Œåˆ™ä¾ç„¶å¯ç”¨å»å™ªã€‚
            // åªæœ‰å½“æš—éƒ¨å¹¿æ³›åˆ†å¸ƒåœ¨ç”»é¢ä¸­å¿ƒï¼ˆè¯´æ˜æ˜¯é»‘ä¸»ä½“ï¼‰æ—¶ï¼Œæ‰ç¦ç”¨å»å™ªã€‚
            // ç®€åŒ–ç‰ˆé€»è¾‘ï¼šåªçœ‹ darkRatioï¼Œå¦‚æœå¤ªé»‘ï¼Œå®å¯å™ªç‚¹å¤šä¸€ç‚¹ä¹Ÿä¸è¦è¯¯æ€ä¸»ä½“ã€‚
            if (darkRatio > 0.05) {
                // [ç´§æ€¥ä¿®æ­£] 
                // åŸé€»è¾‘ï¼šå¤ªé»‘å°±å½»åº•å…³é—­èƒŒæ™¯çº¦æŸ (threshold = -1)
                // ç°é€»è¾‘ï¼šä¸ºäº†è§£å†³â€œç™½é©¬è¢«å‹å¹³â€çš„é—®é¢˜ï¼Œæˆ‘ä»¬å‘ç°ç™½é©¬å›¾çš„ darkRatio å…¶å®å¾ˆä½ï¼ˆèƒŒæ™¯é»‘ï¼Œé©¬ç™½ï¼‰ï¼Œæ‰€ä»¥è¿›ä¸æ¥è¿™é‡Œã€‚
                // è€Œè¿›ä¸æ¥è¿™é‡Œï¼Œå°±ä¼šè¢«å½“æˆæ™®é€šå›¾å¤„ç†ï¼Œç»“æœç™½é©¬èº«ä¸Šå¾®å¼±çš„èµ·ä¼è¢«å½“æˆèƒŒæ™¯å™ªç‚¹æŠ¹å¹³äº†ã€‚
                
                // æ ¹æœ¬åŸå› ï¼šæˆ‘ä»¬è¿‡äºä¾èµ–â€œèƒŒæ™¯æŠ¹å¹³â€æ¥å»å™ªã€‚
                // çœŸæ­£çš„è§£å†³ä¹‹é“ï¼šé™ä½èƒŒæ™¯æŠ¹å¹³çš„åŠ›åº¦ï¼ŒæŠŠå»å™ªä»»åŠ¡äº¤ç»™å‰é¢çš„â€œå¹³æ»‘æ¢¯åº¦â€æ­¥éª¤ã€‚
                
                // æ— è®ºæ˜¯ä¸æ˜¯é»‘å›¾ï¼Œéƒ½æŠŠèƒŒæ™¯åˆ¤å®šé˜ˆå€¼è®¾å¾—æä½ï¼Œç”šè‡³è´Ÿæ•°ï¼Œå½»åº•ç¦ç”¨â€œåŸºäºé«˜åº¦çš„èƒŒæ™¯æŠ¹å¹³â€ã€‚
                // è®©æ³Šæ¾æ–¹ç¨‹è‡ªå·±å»å¹³è¡¡æ¢¯åº¦å’Œé«˜åº¦ï¼Œè€Œä¸æ˜¯äººä¸ºå¼ºè¡Œå‹å¹³ã€‚
                effectiveBgThreshold = -1.0; 
            } else {
                // å³ä½¿æ˜¯ç™½åº•å›¾ï¼Œä¹Ÿå°½é‡ä¸è¦å¼ºè¡ŒæŠ¹å¹³ï¼Œé™¤éç”¨æˆ·æ˜ç¡®è¦æ±‚ï¼ˆæœªæ¥å¯ä»¥åŠ å‚æ•°ï¼‰
                // ç°é˜¶æ®µä¸ºäº†ç¨³å¦¥ï¼ŒæŠŠæ‰€æœ‰å›¾çš„èƒŒæ™¯å¼ºåˆ¶æŠ¹å¹³éƒ½å…³æ‰ã€‚
                // å› ä¸ºâ€œæŠŠæœ‰ç”¨çš„ä¸œè¥¿æŠ¹æ²¡äº†â€æ¯”â€œç•™ä¸‹ä¸€ä¸¤ä¸ªå™ªç‚¹â€ä¸¥é‡å¾—å¤šã€‚
                effectiveBgThreshold = -1.0;
            }
            
            // è®¡ç®—æ•£åº¦ (ä½¿ç”¨ä¸­å¿ƒå·®åˆ†)
            for(let y=0; y<height; y++) {
                for(let x=0; x<width; x++) {
                    const idx = y*width + x;
                    
                    let gx_x = 0;
                    if(x == 0) gx_x = Gx[idx];
                    else if(x == width-1) gx_x = -Gx[idx-1];
                    else gx_x = Gx[idx] - Gx[idx-1];
                    
                    let gy_y = 0;
                    if(y == 0) gy_y = Gy[idx];
                    else if(y == height-1) gy_y = -Gy[idx-width];
                    else gy_y = Gy[idx] - Gy[idx-width];
                    
                    div[idx] = gx_x + gy_y;
                }
            }

            const backgroundLambda = 200.0; // å¢å¼ºèƒŒæ™¯çº¦æŸ
            const omega = 1.8; 
            
            // é¢„è®¡ç®— lambda map å’Œæ¢¯åº¦æƒé‡ map
            const lambdaMap = new Float32Array(width * height);
            const gradientScaleMap = new Float32Array(width * height);
            
            for(let i=0; i<width*height; i++) {
                const protectFactor = edgeMask[i]; // 0..1 from Sobel+Dilation
                
                // ä¿®æ­£ï¼šä½¿ç”¨åŠ¨æ€è®¡ç®—çš„ effectiveBgThreshold
                if (H0[i] < effectiveBgThreshold && protectFactor < 0.1) {
                    lambdaMap[i] = backgroundLambda;
                    gradientScaleMap[i] = 1.0;
                } else {
                    // å¸¸è§„åŒºåŸŸ (ç»“æ„åŒº æˆ– æš—éƒ¨éèƒŒæ™¯åŒº)
                    const minL = 0.005; 
                    
                    // [å…³é”®] å¦‚æœæ˜¯é»‘é©¬å›¾(effectiveBgThreshold < 0)ï¼Œå³ä½¿ H0 æ¥è¿‘ 0ï¼Œæˆ‘ä»¬ä¹Ÿç»™å®ƒä¸€ä¸ªéå¸¸å°çš„ lambda (minL)
                    // è¿™æ ·å®ƒå°±ä¸»è¦å¬ä»æ¢¯åº¦(gradient)çš„æŒ‡æŒ¥ï¼Œä»è€Œä¿ç•™å½¢çŠ¶ã€‚
                    // è€ŒåŸå›¾ H0 ä»…ä»…ä½œä¸ºä¸€ä¸ªæå…¶å¾®å¼±çš„â€œå‚è€ƒé«˜åº¦â€ï¼Œé˜²æ­¢å®ƒé£˜åˆ°å¤©ä¸Šå»ã€‚
                    
                    const maxL = fidelity * 0.5 + 0.1; // ç»“æ„åŒºç»™äºˆæ›´é«˜çš„æƒé‡
                    lambdaMap[i] = minL + (maxL - minL) * protectFactor;
                    
                    let scaleT = (protectFactor - 0.2) / 0.3; // 0.2..0.5 -> 0..1
                    if(scaleT < 0) scaleT = 0;
                    if(scaleT > 1) scaleT = 1;
                    
                    gradientScaleMap[i] = 0.3 + 0.7 * scaleT; // æœ€ä½ä¿ç•™ 30% çš„åŸå§‹æ¢¯åº¦
                }
            }

            for (let iter = 0; iter < iterations; iter++) {
                if (iter % 20 === 0) await new Promise(r => setTimeout(r, 0));
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = y * width + x;
                        
                        const currentDiv = div[idx] * gradientScaleMap[idx];
                        
                        const left = x > 0 ? H[idx - 1] : H[idx];
                        const right = x < width - 1 ? H[idx + 1] : H[idx];
                        const up = y > 0 ? H[idx - width] : H[idx];
                        const down = y < height - 1 ? H[idx + width] : H[idx];
                        
                        const lambda = lambdaMap[idx];
                        
                        const poissonPart = (left + right + up + down - currentDiv);
                        
                        // [æœ€ç»ˆä¿®æ­£] 
                        // åŸç†ï¼šH0 æ˜¯åŸºå‡†é«˜åº¦ã€‚lambda æ˜¯æ‹‰åŠ›ã€‚
                        // å¦‚æœ lambda å¾ˆå° (minL=0.005)ï¼ŒH å‡ ä¹å®Œå…¨ç”± poissonPart (æ¢¯åº¦) å†³å®šï¼ŒH0 åªæ˜¯ä¸ªæå…¶å¾®å¼±çš„å‚è€ƒã€‚
                        // å¦‚æœ lambda å¾ˆå¤§ (backgroundLambda=200)ï¼ŒH ä¼šè¢«å¼ºè¡Œæ‹‰å‘ H0ã€‚
                        // æ—¢ç„¶æˆ‘ä»¬å·²ç»ç¦ç”¨äº†èƒŒæ™¯å¼ºçº¦æŸ(effectiveBgThreshold=-1)ï¼Œlambda æ°¸è¿œæ˜¯å°çš„ã€‚
                        // æ‰€ä»¥è¿™é‡Œçš„ dataPart ä»…ä»…æ˜¯é˜²æ­¢é«˜åº¦é£˜ç§»çš„é”šç‚¹ï¼Œä¸ä¼šå¯¼è‡´ç‰©ä½“æ¶ˆå¤±ã€‚
                        
                        const dataPart = lambda * H0[idx];
                        
                        const val = (poissonPart + dataPart) / (4 + lambda);
                        
                        H[idx] = H[idx] + omega * (val - H[idx]);
                    }
                }
            }
            
            for(let i=0; i<H.length; i++) {
                if(H[i] < 0) H[i] = 0;
                if(H[i] > 255) H[i] = 255;
            }
            
            return H;
        }

        // 6. å¼•å¯¼æ»¤æ³¢ (Guided Filter) - O(N) å¤æ‚åº¦
        function applyGuidedFilter(I, p, w, h, r, eps) {
            // I: å¼•å¯¼å›¾ (0-1), p: è¾“å…¥å›¾ (æ¢¯åº¦), r: åŠå¾„, eps: æ­£åˆ™åŒ–å‚æ•°
            
            function boxFilter(src, dst, radius) {
                const temp = new Float32Array(w * h);
                const size = w * h;
                
                // Horizontal
                for(let y=0; y<h; y++) {
                    for(let x=0; x<w; x++) {
                        let sum = 0;
                        let count = 0;
                        const start = Math.max(0, x-radius);
                        const end = Math.min(w-1, x+radius);
                        
                        for(let k=start; k<=end; k++) {
                            sum += src[y*w + k];
                            count++;
                        }
                        temp[y*w + x] = sum / count;
                    }
                }
                
                // Vertical
                for(let x=0; x<w; x++) {
                    for(let y=0; y<h; y++) {
                        let sum = 0;
                        let count = 0;
                        const start = Math.max(0, y-radius);
                        const end = Math.min(h-1, y+radius);
                        
                        for(let k=start; k<=end; k++) {
                            sum += temp[k*w + x];
                            count++;
                        }
                        dst[y*w + x] = sum / count;
                    }
                }
            }

            const size = w * h;
            const mean_I = new Float32Array(size);
            const mean_p = new Float32Array(size);
            const mean_Ip = new Float32Array(size);
            const mean_II = new Float32Array(size);
            
            boxFilter(I, mean_I, r);
            boxFilter(p, mean_p, r);
            
            // mean_Ip = mean(I .* p)
            const Ip = new Float32Array(size);
            const II = new Float32Array(size);
            for(let i=0; i<size; i++) {
                Ip[i] = I[i] * p[i];
                II[i] = I[i] * I[i];
            }
            boxFilter(Ip, mean_Ip, r);
            boxFilter(II, mean_II, r);
            
            // è®¡ç®—çº¿æ€§ç³»æ•° a, b
            const a = new Float32Array(size);
            const b = new Float32Array(size);
            
            for(let i=0; i<size; i++) {
                const var_I = mean_II[i] - mean_I[i] * mean_I[i];
                const cov_Ip = mean_Ip[i] - mean_I[i] * mean_p[i];
                
                a[i] = cov_Ip / (var_I + eps);
                b[i] = mean_p[i] - a[i] * mean_I[i];
            }
            
            const mean_a = new Float32Array(size);
            const mean_b = new Float32Array(size);
            boxFilter(a, mean_a, r);
            boxFilter(b, mean_b, r);
            
            const q = new Float32Array(size);
            for(let i=0; i<size; i++) {
                q[i] = mean_a[i] * I[i] + mean_b[i];
            }
            
            return q;
        }

        function generateNormalMap(heightData, width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            const imgData = ctx.createImageData(width, height);
            const data = imgData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const l = (x > 0) ? heightData[y * width + x - 1] : heightData[idx];
                    const r = (x < width - 1) ? heightData[y * width + x + 1] : heightData[idx];
                    const t = (y > 0) ? heightData[(y - 1) * width + x] : heightData[idx];
                    const b = (y < height - 1) ? heightData[(y + 1) * width + x] : heightData[idx];

                    const nx = (l - r);
                    const ny = (t - b);
                    const nz = 2.0; 
                    
                    const len = Math.sqrt(nx*nx + ny*ny + nz*nz);
                    data[idx*4] = (nx/len + 1) * 127.5;
                    data[idx*4+1] = (ny/len + 1) * 127.5;
                    data[idx*4+2] = (nz/len + 1) * 127.5;
                    data[idx*4+3] = 255;
                }
            }
            ctx.putImageData(imgData, 0, 0);
            return canvas.toDataURL();
        }

        // ================= ä¸»æµç¨‹ =================

        async function processImage(file) {
            showLoading(true, "è¯»å–å›¾åƒ...");
            try {
                let width, height, imageData;
                
                if (file.name.toLowerCase().endsWith('.tif') || file.name.toLowerCase().endsWith('.tiff')) {
                    const buffer = await file.arrayBuffer();
                    const ifds = UTIF.decode(buffer);
                    if (ifds.length > 0) {
                        const ifd = ifds[0];
                        UTIF.decodeImage(buffer, ifd);
                        const rgba = UTIF.toRGBA8(ifd); 
                        width = ifd.width;
                        height = ifd.height;
                        imageData = new ImageData(new Uint8ClampedArray(rgba), width, height);
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.putImageData(imageData, 0, 0);
                        
                        originalImageData = imageData;
                        document.getElementById('previewOriginal').src = canvas.toDataURL();
                    } else {
                        throw new Error("æ— æ•ˆçš„ TIFF æ–‡ä»¶");
                    }
                } else {
                    const bitmap = await createImageBitmap(file);
                    width = bitmap.width;
                    height = bitmap.height;
                    
                    if (width * height > 2048 * 2048) {
                        if (!confirm("å›¾åƒå°ºå¯¸éå¸¸å¤§ï¼Œå¯èƒ½ä¼šå¯¼è‡´æµè§ˆå™¨å¡é¡¿ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ")) {
                            showLoading(false);
                            return;
                        }
                    }

                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(bitmap, 0, 0, width, height);
                    originalImageData = ctx.getImageData(0, 0, width, height);
                    
                    document.getElementById('previewOriginal').src = canvas.toDataURL();
                }
                
                document.getElementById('previewOriginal').style.display = 'block';
                document.getElementById('generateBtn').disabled = false;
                
                generateModel();
                
                showLoading(false);
            } catch (e) {
                console.error(e);
                alert("å›¾åƒå¤„ç†å‡ºé”™: " + e.message);
                showLoading(false);
            }
        }

        // ================== æè´¨ç®¡ç†ç³»ç»Ÿ ==================
        function createMaterial() {
            const mode = document.getElementById('materialMode').value;
            const useOverlay = document.getElementById('overlayTexture').checked;
            const useHydro = document.getElementById('hydroEffect').checked;
            
            let newMaterial;
            
            if (mode === 'wireframe') {
                newMaterial = new THREE.MeshBasicMaterial({ color: 0x60a5fa, wireframe: true });
            } else if (mode === 'normal') {
                newMaterial = new THREE.MeshNormalMaterial();
            } else if (mode === 'pbr_clay') {
                newMaterial = new THREE.MeshStandardMaterial({
                    color: 0x9e7151, 
                    roughness: 0.7, 
                    metalness: 0.1, 
                    side: THREE.DoubleSide,
                    normalMap: currentNormalTexture,
                    normalScale: new THREE.Vector2(1, 1)
                });
            } else if (mode === 'pbr_metal') {
                newMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffd700, 
                    roughness: 0.2, 
                    metalness: 1.0, 
                    side: THREE.DoubleSide,
                    normalMap: currentNormalTexture,
                    normalScale: new THREE.Vector2(1, 1)
                });
            } else if (mode === 'terrain') {
                // åœ°å½¢æ¨¡å¼é€»è¾‘
                const matConfig = {
                    side: THREE.DoubleSide,
                    normalMap: currentNormalTexture,
                    normalScale: new THREE.Vector2(1, 1),
                    flatShading: false
                };

                // å åŠ åŸå›¾çº¹ç†
                if (useOverlay && currentDiffuseTexture) {
                    matConfig.map = currentDiffuseTexture;
                    matConfig.color = 0xffffff;
                    matConfig.vertexColors = false; // ä½¿ç”¨çº¹ç†æ—¶ç¦ç”¨é¡¶ç‚¹é¢œè‰²
                } else {
                    matConfig.vertexColors = true; // ä½¿ç”¨é«˜åº¦æ¢¯åº¦ä¼ªå½©
                }

                // æ™ºèƒ½æ°´ä½“å…‰æ³½ (Hydro Effect)
                if (useHydro && currentRoughnessTexture) {
                    // ä½¿ç”¨ Standard æè´¨ä»¥æ”¯æŒ roughnessMap
                    matConfig.roughnessMap = currentRoughnessTexture;
                    matConfig.metalness = 0.1;
                    matConfig.roughness = 1.0; 
                    newMaterial = new THREE.MeshStandardMaterial(matConfig);
                } else {
                    // ç»å…¸ Phong æè´¨
                    matConfig.specular = 0x444444;
                    matConfig.shininess = 30;
                    newMaterial = new THREE.MeshPhongMaterial(matConfig);
                }

            } else {
                // é»˜è®¤ Phong
                newMaterial = new THREE.MeshPhongMaterial({
                    color: 0x94a3b8, specular: 0x111111, shininess: 30, side: THREE.DoubleSide,
                    normalMap: currentNormalTexture,
                    normalScale: new THREE.Vector2(1, 1)
                });
            }
            return newMaterial;
        }

        function updateMaterial() {
            if (!currentMesh) return;
            const newMat = createMaterial();
            if (currentMesh.material) currentMesh.material.dispose();
            currentMesh.material = newMat;
            
            // åˆ‡æ¢æè´¨åé‡æ–°åº”ç”¨é˜´å½±è®¾ç½®
            const shadowEnabled = document.getElementById('enableShadows').checked;
            currentMesh.castShadow = shadowEnabled;
            currentMesh.receiveShadow = shadowEnabled;
        }

        async function generateModel() {
            if (!originalImageData) return;
            
            const maxRes = parseInt(document.getElementById('maxResolution').value);
            let workData = originalImageData;
            let width = originalImageData.width;
            let height = originalImageData.height;

            showLoading(true, "å‡†å¤‡æ•°æ®...");
            await new Promise(r => setTimeout(r, 50));

            if (maxRes > 0 && (width > maxRes || height > maxRes)) {
                const ratio = Math.min(maxRes / width, maxRes / height);
                const newW = Math.floor(width * ratio);
                const newH = Math.floor(height * ratio);
                
                const canvas = document.createElement('canvas');
                canvas.width = newW;
                canvas.height = newH;
                const ctx = canvas.getContext('2d');
                
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                tempCanvas.getContext('2d').putImageData(originalImageData, 0, 0);
                
                ctx.drawImage(tempCanvas, 0, 0, newW, newH);
                workData = ctx.getImageData(0, 0, newW, newH);
                width = newW;
                height = newH;
            }

            const depthScale = parseInt(document.getElementById('depthScale').value);
            
            try {
                let heightData;
                
                const denoiseStrength = parseFloat(document.getElementById('denoiseStrength').value);
                const structureProtect = parseFloat(document.getElementById('structureProtect').value);
                const fidelity = parseFloat(document.getElementById('fidelity').value);
                const surfacePolish = parseFloat(document.getElementById('surfacePolish').value);
                const flatnessThreshold = parseFloat(document.getElementById('flatnessThreshold').value);
                
                showLoading(true, "è®¡ç®—æ¢¯åº¦åœº...");
                const { Gx, Gy } = computeGradients(workData.data, width, height);
                
                showLoading(true, "æ™ºèƒ½è¾¹ç•Œæ£€æµ‹ (Hessianå¢å¼º)...");
                // ä¼ å…¥åŸå§‹å›¾åƒæ•°æ® workData.data ä»¥è¿›è¡Œ Hessian è®¡ç®—
                const edgeMask = computeEdgeMask(Gx, Gy, workData.data, width, height, structureProtect);
                
                showLoading(true, "è‡ªé€‚åº”ç»“æ„å¹³æ»‘...");
                await new Promise(r => setTimeout(r, 10));
                
                const guide = new Float32Array(width * height);
                for(let i=0; i<width*height; i++) {
                    guide[i] = (workData.data[i*4] + workData.data[i*4+1] + workData.data[i*4+2]) / 3.0 / 255.0;
                }
                
                const radius = Math.max(1, Math.floor(denoiseStrength));
                const eps = 0.001 + (denoiseStrength * 0.005); 
                
                const smoothGx = applyGuidedFilter(guide, Gx, width, height, radius, eps);
                const smoothGy = applyGuidedFilter(guide, Gy, width, height, radius, eps);
                
                const smoothG = { Gx: smoothGx, Gy: smoothGy };
                
                showLoading(true, "æ³Šæ¾é‡å»ºè¡¨é¢ (å«ä¿çœŸçº¦æŸ)...");
                heightData = await solvePoissonWithFidelity(smoothG.Gx, smoothG.Gy, workData.data, width, height, fidelity, edgeMask, 50);
                
                if (surfacePolish > 0) {
                    showLoading(true, "æœ€ç»ˆæ›²é¢æŠ›å…‰...");
                    await new Promise(r => setTimeout(r, 10));
                    
                    const heightGuide = new Float32Array(width * height);
                    const maxH = 255.0; 
                    for(let i=0; i<heightData.length; i++) heightGuide[i] = heightData[i] / maxH;
                    
                    const polishRadius = Math.max(1, Math.floor(surfacePolish));
                    const polishEps = 0.002; 
                    
                    heightData = applyGuidedFilter(heightGuide, heightData, width, height, polishRadius, polishEps);
                }
                
                document.getElementById('previewNormal').src = generateNormalMap(heightData, width, height);
                document.getElementById('previewNormal').style.display = 'block';

                showLoading(true, "æ„å»ºè‡ªé€‚åº”ç½‘æ ¼...");
                await new Promise(r => setTimeout(r, 10));
                
                if (currentMesh) {
                    scene.remove(currentMesh);
                    currentMesh.geometry.dispose();
                    currentMesh.material.dispose();
                }

                const targetWidthMM = 100.0;
                const targetZ = parseInt(document.getElementById('depthScale').value); 
                const floorThreshold = parseFloat(document.getElementById('floorThreshold').value);
                const precision = parseFloat(document.getElementById('optPrecision').value);
                
                let minH_val = Infinity;
                for(let j=0; j<heightData.length; j++) {
                    if(heightData[j] < minH_val) minH_val = heightData[j];
                }

                function getZInfo(x, y) {
                    if(x < 0) x = 0; if(x >= width) x = width - 1;
                    if(y < 0) y = 0; if(y >= height) y = height - 1;
                    
                    const idx = Math.floor(y) * width + Math.floor(x);
                    const val = heightData[idx];
                    
                    const shiftedH = val - minH_val;
                    const normalizedH = shiftedH / 255.0;
                    
                    let finalZ_base = normalizedH; 
                    // let physicalZ = finalZ_base * targetZ; // ä¸å†ä½¿ç”¨è®¡ç®—åçš„é«˜åº¦æ¥åšé˜ˆå€¼åˆ¤æ–­
                    
                    // [ä¿®æ­£] ä½¿ç”¨åŸå§‹å›¾åƒäº®åº¦ä½œä¸ºâ€œåº•æ¿å™ªç‚¹æ¶ˆé™¤â€çš„ä¾æ®
                    // è§£å†³é—®é¢˜ï¼šå¹³æ»‘ç‰©ä½“ï¼ˆå¦‚æ ‘å¹²ï¼‰è™½ç„¶æ¢¯åº¦å°å¯¼è‡´ Poisson é‡å»ºé«˜åº¦ä½ï¼Œä½†åŸå›¾æ˜¯æœ‰äº®åº¦çš„ï¼Œä¸åº”è¢«å½“åšå™ªç‚¹æŠ¹é™¤ã€‚
                    const r = workData.data[idx * 4];
                    const g = workData.data[idx * 4 + 1];
                    const b = workData.data[idx * 4 + 2];
                    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                    
                    // è®¡ç®—è¯¥åƒç´ åœ¨â€œåŸå›¾äº®åº¦â€æ„ä¹‰ä¸‹çš„ç‰©ç†é«˜åº¦
                    const original_physical_height = (brightness / 255.0) * targetZ;
                    
                    // å¦‚æœåŸå›¾äº®åº¦å¯¹åº”çš„é«˜åº¦ä½äºé˜ˆå€¼ï¼Œæ‰è®¤ä¸ºæ˜¯åº•æ¿å™ªç‚¹å¹¶æŠ¹å¹³
                    if (original_physical_height < floorThreshold) {
                        finalZ_base = 0.0;
                    }
                    
                    return { z: finalZ_base, h: normalizedH };
                }
                
                function getZ(x, y) {
                    return getZInfo(x, y).z;
                }

                function getZBilinear(x, y) {
                    const x0 = Math.floor(x);
                    const y0 = Math.floor(y);
                    const x1 = Math.min(x0 + 1, width - 1);
                    const y1 = Math.min(y0 + 1, height - 1);
                    
                    const u = x - x0;
                    const v = y - y0;
                    
                    const z00 = getZ(x0, y0);
                    const z01 = getZ(x1, y0);
                    const z10 = getZ(x0, y1);
                    const z11 = getZ(x1, y1);
                    
                    return z00*(1-u)*(1-v) + z01*u*(1-v) + z10*(1-u)*v + z11*u*v;
                }

                const scaleFactor = targetWidthMM / width;
                
                function getPos(x, y) {
                    const px = (x - width / 2) * scaleFactor;
                    const py = -(y - height / 2) * scaleFactor; 
                    const info = getZInfo(x, y);
                    if (info.z === 0.0) info.h = 0.0;
                    
                    return { x: px, y: py, z: info.z, h: info.h };
                }

                function hexToRgb(hex) {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? [
                        parseInt(result[1], 16),
                        parseInt(result[2], 16),
                        parseInt(result[3], 16)
                    ] : [0, 0, 0];
                }

                function getTerrainColor(h) {
                    if(h <= terrainStops[0].p) return hexToRgb(terrainStops[0].c);
                    if(h >= terrainStops[terrainStops.length-1].p) return hexToRgb(terrainStops[terrainStops.length-1].c);
                    
                    for(let i=0; i<terrainStops.length-1; i++) {
                        if(h >= terrainStops[i].p && h <= terrainStops[i+1].p) {
                            const t = (h - terrainStops[i].p) / (terrainStops[i+1].p - terrainStops[i].p);
                            const c1 = hexToRgb(terrainStops[i].c);
                            const c2 = hexToRgb(terrainStops[i+1].c);
                            return [
                                c1[0] + (c2[0] - c1[0]) * t,
                                c1[1] + (c2[1] - c1[1]) * t,
                                c1[2] + (c2[2] - c1[2]) * t
                            ];
                        }
                    }
                    return hexToRgb(terrainStops[terrainStops.length-1].c);
                }

                const vertices = [];
                const colors = []; 
                const indices = [];
                
                const stack = [0, 0, width - 1, height - 1];
                
                const tol = precision * targetZ; 

                while (stack.length > 0) {
                    const y1 = stack.pop();
                    const x1 = stack.pop();
                    const y0 = stack.pop();
                    const x0 = stack.pop();
                    
                    if (y1 - y0 <= 1 && x1 - x0 <= 1) {
                        addQuad(x0, y0, x1, y1);
                        continue;
                    }
                    
                    const xc = Math.floor((x0 + x1) / 2);
                    const yc = Math.floor((y0 + y1) / 2);
                    
                    const samples = [
                        {x: xc, y: yc},
                        {x: xc, y: y0}, {x: xc, y: y1},
                        {x: x0, y: yc}, {x: x1, y: yc}
                    ];
                    
                    let maxErr = 0;
                    const z00 = getZ(x0, y0);
                    const z01 = getZ(x1, y0);
                    const z10 = getZ(x0, y1);
                    const z11 = getZ(x1, y1);
                    
                    for (let k = 0; k < samples.length; k++) {
                        const s = samples[k];
                        const realZ_norm = getZ(s.x, s.y);
                        
                        const u = (s.x - x0) / (x1 - x0);
                        const v = (s.y - y0) / (y1 - y0);
                        const predZ_norm = z00*(1-u)*(1-v) + z01*u*(1-v) + z10*(1-u)*v + z11*u*v;
                        
                        const realZ_mm = realZ_norm * targetZ;
                        const predZ_mm = predZ_norm * targetZ;
                        
                        const err = Math.abs(realZ_mm - predZ_mm);
                        if (err > maxErr) maxErr = err;
                    }
                    
                    if (maxErr > tol) {
                        stack.push(x0, y0, xc, yc); 
                        stack.push(xc, y0, x1, yc); 
                        stack.push(x0, yc, xc, y1); 
                        stack.push(xc, yc, x1, y1); 
                    } else {
                        addQuad(x0, y0, x1, y1);
                    }
                }
                
                function addQuad(x0, y0, x1, y1) {
                    const p00 = getPos(x0, y0);
                    const p01 = getPos(x0, y1);
                    const p11 = getPos(x1, y1);
                    const p10 = getPos(x1, y0);
                    
                    const deleteZero = document.getElementById('optDeleteZero').checked;
                    if (deleteZero) {
                        if (p00.z === 0 && p01.z === 0 && p11.z === 0 && p10.z === 0) return;
                    }

                    pushVert(p00); pushVert(p01); pushVert(p11);
                    pushVert(p00); pushVert(p11); pushVert(p10);
                }
                
                function pushVert(p) {
                    vertices.push(p.x, p.y, p.z);
                    const rgb = getTerrainColor(p.h);
                    colors.push(rgb[0]/255.0, rgb[1]/255.0, rgb[2]/255.0);
                }

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                showLoading(true, "ä¼˜åŒ–é¡¶ç‚¹...");
                const mergedGeometry = THREE.BufferGeometryUtils.mergeVertices(geometry);
                mergedGeometry.computeVertexNormals();
                
                // ================== æ–°å¢ï¼šç½‘æ ¼ç»†åŒ–é€»è¾‘ (Mesh Refinement) ==================
                // 1. ç”Ÿæˆæ³•çº¿è´´å›¾çº¹ç†
                const normalCanvas = document.createElement('canvas');
                normalCanvas.width = width;
                normalCanvas.height = height;
                const ncCtx = normalCanvas.getContext('2d');
                const ncData = ncCtx.createImageData(width, height);
                
                // å½’ä¸€åŒ–æ³•çº¿åˆ° RGB [0,255]
                for(let i=0; i<width*height; i++) {
                    const nx = -Gx[i];
                    const ny = -Gy[i];
                    const nz = 1.0;
                    const len = Math.sqrt(nx*nx + ny*ny + nz*nz);
                    
                    ncData.data[i*4] = ((nx/len)*0.5 + 0.5) * 255;   // R
                    ncData.data[i*4+1] = ((ny/len)*0.5 + 0.5) * 255; // G
                    ncData.data[i*4+2] = ((nz/len)*0.5 + 0.5) * 255; // B (å¤§è‡´æœä¸Š)
                    ncData.data[i*4+3] = 255;
                }
                ncCtx.putImageData(ncData, 0, 0);
                const normalTexture = new THREE.CanvasTexture(normalCanvas);
                currentNormalTexture = normalTexture; // ä¿å­˜å¼•ç”¨
                
                // 2. ç”ŸæˆåŸå›¾çº¹ç† (Diffuse)
                const diffuseCanvas = document.createElement('canvas');
                diffuseCanvas.width = width;
                diffuseCanvas.height = height;
                const diffCtx = diffuseCanvas.getContext('2d');
                diffCtx.putImageData(workData, 0, 0);
                currentDiffuseTexture = new THREE.CanvasTexture(diffuseCanvas);
                currentDiffuseTexture.encoding = THREE.sRGBEncoding;
                
                // 3. ç”Ÿæˆæ™ºèƒ½å…‰æ³½è´´å›¾ (Roughness) - åŸºäºé«˜åº¦
                // ä½å¤„(Hå°) -> Roughnesså°(å…‰æ»‘); é«˜å¤„(Hå¤§) -> Roughnesså¤§(ç²—ç³™)
                const roughCanvas = document.createElement('canvas');
                roughCanvas.width = width;
                roughCanvas.height = height;
                const rCtx = roughCanvas.getContext('2d');
                const rData = rCtx.createImageData(width, height);
                
                for(let i=0; i<width*height; i++) {
                    // heightData æ˜¯ 0-255
                    const h = heightData[i] / 255.0; // 0..1
                    
                    // æ˜ å°„é€»è¾‘ï¼š
                    // æ°´é¢/ä½åœ° (h<0.2): éå¸¸å…‰æ»‘ (roughness ~ 0.2)
                    // é™†åœ°/é«˜å±± (h>0.2): é€æ¸ç²—ç³™ (roughness 0.5 -> 1.0)
                    
                    let rVal;
                    if(h < 0.1) {
                        rVal = 0.15; // ææ¹¿æ¶¦
                    } else if(h < 0.3) {
                        // è¿‡æ¸¡å¸¦
                        rVal = 0.15 + (h - 0.1) / 0.2 * 0.6; 
                    } else {
                        rVal = 0.8 + (Math.random() * 0.2); // éšæœºå™ªç‚¹å¢åŠ ç²—ç³™æ„Ÿ
                    }
                    
                    const val = Math.floor(rVal * 255);
                    rData.data[i*4] = val;   // R
                    rData.data[i*4+1] = val; // G (Metalness unused mostly)
                    rData.data[i*4+2] = val; // B
                    rData.data[i*4+3] = 255;
                }
                rCtx.putImageData(rData, 0, 0);
                currentRoughnessTexture = new THREE.CanvasTexture(roughCanvas);

                const material = createMaterial();

                currentMesh = new THREE.Mesh(mergedGeometry, material);
                currentMesh.scale.z = targetZ;
                
                currentMesh.rotation.x = -Math.PI / 2;
                
                // åº”ç”¨é˜´å½±è®¾ç½®
                const shadowEnabled = document.getElementById('enableShadows').checked;
                currentMesh.castShadow = shadowEnabled;
                currentMesh.receiveShadow = shadowEnabled;
                scene.add(currentMesh);

                const faceCount = mergedGeometry.index ? mergedGeometry.index.count / 3 : mergedGeometry.attributes.position.count / 3;
                document.getElementById('optFaceCount').textContent = Math.floor(faceCount).toLocaleString();

                const size = Math.max(width, height);
                const fov = camera.fov * (Math.PI / 180);
                
                geometry.computeBoundingBox();
                const box = geometry.boundingBox;
                const sizeX = box.max.x - box.min.x;
                const sizeY = box.max.y - box.min.y;
                const maxDim = Math.max(sizeX, sizeY);
                
                const fitDist = (maxDim / 2) / Math.tan(fov / 2);
                
                camera.position.set(0, fitDist * 0.8, fitDist * 0.6); 
                controls.target.set(0, 0, 0);
                controls.update();

                document.getElementById('exportSTLBtn').disabled = false;
                document.getElementById('exportOBJBtn').disabled = false;
                
                const zSliderContainer = document.getElementById('zSliderContainer');
                const zSliderThumb = document.getElementById('zSliderThumb');
                const zSliderVal = document.getElementById('zSliderVal');
                zSliderContainer.style.display = 'flex';
                
                const minZ = 1, maxZ = 200;
                const percent = ((targetZ - minZ) / (maxZ - minZ)) * 100;
                zSliderThumb.style.bottom = `${percent}%`;
                zSliderVal.textContent = `${targetZ}mm`;
                
                initZSlider();

            } catch (error) {
                console.error(error);
                alert("ç”Ÿæˆå¤±è´¥: " + error.message);
            } finally {
                showLoading(false);
            }
        }

        function exportSTL() {
            if (!currentMesh) return;
            
            const originalRotation = currentMesh.rotation.x;
            currentMesh.rotation.x = 0; 
            
            currentMesh.updateMatrixWorld();
            
            const exporter = new THREE.STLExporter();
            const result = exporter.parse(currentMesh, { binary: true });
            
            currentMesh.rotation.x = originalRotation;
            currentMesh.updateMatrixWorld();
            
            const blob = new Blob([result], { type: 'application/octet-stream' });
            downloadBlob(blob, 'model.stl');
        }

        function exportOBJ() {
            if (!currentMesh) return;
            
            const originalRotation = currentMesh.rotation.x;
            currentMesh.rotation.x = 0;
            currentMesh.updateMatrixWorld();
            
            const exporter = new THREE.OBJExporter();
            const result = exporter.parse(currentMesh);
            
            currentMesh.rotation.x = originalRotation;
            currentMesh.updateMatrixWorld();
            
            const blob = new Blob([result], { type: 'text/plain' });
            downloadBlob(blob, 'model.obj');
        }
        
        function initZSlider() {
            const track = document.getElementById('zSliderTrack');
            const thumb = document.getElementById('zSliderThumb');
            const valDisplay = document.getElementById('zSliderVal');
            const depthInput = document.getElementById('depthScale');
            const depthDisplay = document.getElementById('depthScaleVal');
            
            let isDragging = false;
            
            const updateZ = (clientY) => {
                const rect = track.getBoundingClientRect();
                let percent = (rect.bottom - clientY) / rect.height;
                if (percent < 0) percent = 0;
                if (percent > 1) percent = 1;
                
                thumb.style.bottom = `${percent * 100}%`;
                
                const minZ = 1, maxZ = 200;
                const zVal = Math.round(minZ + percent * (maxZ - minZ));
                
                valDisplay.textContent = `${zVal}mm`;
                
                depthInput.value = zVal;
                depthDisplay.textContent = zVal;
                
                if (currentMesh) {
                    currentMesh.scale.z = zVal;
                }
            };
            
            thumb.onmousedown = (e) => {
                isDragging = true;
                e.stopPropagation(); 
            };
            
            track.onmousedown = (e) => {
                isDragging = true;
                updateZ(e.clientY);
                e.stopPropagation();
            };
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    updateZ(e.clientY);
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            depthInput.addEventListener('input', () => {
                const zVal = parseInt(depthInput.value);
                const minZ = 1, maxZ = 200;
                const percent = (zVal - minZ) / (maxZ - minZ);
                thumb.style.bottom = `${percent * 100}%`;
                valDisplay.textContent = `${zVal}mm`;
                if (currentMesh) currentMesh.scale.z = zVal;
            });
        }

        function downloadBlob(blob, filename) {
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }

        function showLoading(show, text) {
            const el = document.getElementById('loadingOverlay');
            el.style.display = show ? 'flex' : 'none';
            if (text) document.getElementById('loadingText').textContent = text;
        }

        function initEvents() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            const dragOverlay = document.getElementById('dragOverlay');

            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => {
                if (e.target.files[0]) processImage(e.target.files[0]);
            });

            let dragCounter = 0; 

            document.body.addEventListener('dragenter', (e) => {
                e.preventDefault();
                dragCounter++;
                dragOverlay.style.display = 'flex';
            });

            document.body.addEventListener('dragover', (e) => {
                e.preventDefault(); 
            });

            document.body.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dragCounter--;
                if (dragCounter === 0) {
                    dragOverlay.style.display = 'none';
                }
            });

            document.body.addEventListener('drop', (e) => {
                e.preventDefault();
                dragCounter = 0;
                dragOverlay.style.display = 'none';
                
                if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                    processImage(e.dataTransfer.files[0]);
                }
            });

            document.getElementById('generateBtn').addEventListener('click', generateModel);
            document.getElementById('exportSTLBtn').addEventListener('click', exportSTL);
            document.getElementById('exportOBJBtn').addEventListener('click', exportOBJ);

            ['denoiseStrength', 'structureProtect', 'fidelity', 'depthScale', 'floorThreshold', 'surfacePolish', 'flatnessThreshold'].forEach(id => {
                const el = document.getElementById(id);
                const display = document.getElementById(id + 'Val');
                el.addEventListener('input', () => {
                    display.textContent = el.value;
                });
            });
            
            window.addEventListener('paste', (e) => {
                if (e.clipboardData && e.clipboardData.items) {
                    const items = e.clipboardData.items;
                    for (let i = 0; i < items.length; i++) {
                        if (items[i].type.indexOf('image') !== -1) {
                            const blob = items[i].getAsFile();
                            processImage(blob);
                            break;
                        }
                    }
                }
            });

            document.getElementById('materialMode').addEventListener('change', updateMaterial);
            document.getElementById('overlayTexture').addEventListener('change', updateMaterial);
            document.getElementById('hydroEffect').addEventListener('change', updateMaterial);
            
            document.getElementById('enableShadows').addEventListener('change', (e) => {
                if(g_dirLight) {
                    g_dirLight.castShadow = e.target.checked;
                }
                if(currentMesh) {
                    currentMesh.castShadow = e.target.checked;
                    currentMesh.receiveShadow = e.target.checked;
                    // å¼ºåˆ¶åˆ·æ–°æè´¨ä»¥åº”ç”¨ ShadowMap
                    currentMesh.material.needsUpdate = true;
                }
            });
            
            document.getElementById('showGrid').addEventListener('change', (e) => {
                if(gridHelper) gridHelper.visible = e.target.checked;
            });
            
            document.getElementById('maxResolution').addEventListener('change', (e) => {
                const warning = document.getElementById('resWarning');
                if (e.target.value === '0') {
                    warning.style.display = 'block';
                } else {
                    warning.style.display = 'none';
                }
            });

            const sidebar = document.getElementById('sidebar');
            document.getElementById('toggleSidebar').addEventListener('click', () => {
                sidebar.classList.toggle('collapsed');
            });

            document.getElementById('startOptBtn').addEventListener('click', () => {
                generateModel();
            });
            
            // ================== æ–°å¢ï¼šç½‘æ ¼ç»†åŒ–é€»è¾‘ (Mesh Refinement) ==================
            // åŸç†ï¼šåœ¨ç”Ÿæˆ Mesh ä¹‹å‰ï¼Œå¯¹é«˜åº¦å›¾è¿›è¡ŒåŒä¸‰æ¬¡æ’å€¼ (Bicubic Interpolation) æˆ–ç®€å•çš„ç»†åˆ†ã€‚
            // è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨ Three.js PlaneGeometry çš„ç»†åˆ†å‚æ•°æ¥æ§åˆ¶ç½‘æ ¼å¯†åº¦ï¼Œè€Œä¸æ˜¯ç›´æ¥ä¿®æ”¹é«˜åº¦å›¾æ•°ç»„ã€‚
            // ä¹‹å‰çš„ maxResolution åªæ˜¯é™åˆ¶äº†å›¾ç‰‡å¤§å°ï¼Œç°åœ¨æˆ‘ä»¬éœ€è¦åœ¨ç”Ÿæˆ Mesh æ—¶å¢åŠ æ®µæ•°ã€‚
            
            // æ³¨æ„ï¼šgenerateModel å‡½æ•°ä¸­å·²ç»æœ‰ const geometry = new THREE.PlaneGeometry(w, h, w - 1, h - 1);
            // è¿™é‡Œçš„ w-1 å’Œ h-1 å†³å®šäº†ç½‘æ ¼é¢æ•°ã€‚å¦‚æœå›¾ç‰‡åˆ†è¾¨ç‡æœ¬èº«å¾ˆé«˜ï¼Œç½‘æ ¼å°±å·²ç»å¾ˆå¯†äº†ã€‚
            // é—®é¢˜å¯èƒ½å‡ºåœ¨â€œè§†è§‰ä¸Šçš„ç²—ç³™â€æˆ–è€…â€œæ³•çº¿è®¡ç®—çš„ç²¾åº¦â€ã€‚
            
            // æ—¢ç„¶æ³•çº¿è´´å›¾çœ‹èµ·æ¥æ²¡é—®é¢˜ï¼Œä½† 3D æ¨¡å‹æœ‰é—®é¢˜ï¼Œè¯´æ˜æ³•çº¿åˆ°é«˜åº¦çš„ç§¯åˆ†è¿‡ç¨‹æŸå¤±äº†ä¿¡æ¯ï¼Œ
            // æˆ–è€… Mesh çš„é¡¶ç‚¹æ³•çº¿ (Vertex Normals) è®¡ç®—æœ‰é—®é¢˜ã€‚
            
            // å°è¯•å¼€å¯å¹³æ»‘ç€è‰² (Smooth Shading)
            // åœ¨ generateModel ä¸­ï¼šgeometry.computeVertexNormals(); å·²ç»æœ‰äº†ã€‚
            
            // æœ€å¤§çš„å«Œç–‘ï¼šç½‘æ ¼åˆ†è¾¨ç‡ (Vertices) ä¸è¶³ã€‚
            // å¦‚æœå›¾ç‰‡è¢«ç¼©æ”¾è¿‡ (æ¯”å¦‚ 1024x1024 è¢«ç¼©åˆ° 512x512)ï¼Œé‚£ä¹ˆ Mesh çš„ç»†èŠ‚å°±ä¼šä¸¢å¤±ã€‚
            // ç°åœ¨çš„é€»è¾‘æ˜¯ï¼šgeometry çš„åˆ†æ®µæ•°ç­‰äºå›¾ç‰‡çš„åƒç´ æ•°ã€‚è¿™æ˜¯ 1:1 çš„å¯¹åº”ï¼Œç†è®ºä¸Šæ˜¯æœ€æ¸…æ™°çš„ã€‚
            
            // é‚£ä¹ˆé—®é¢˜å¯èƒ½å‡ºåœ¨â€œæ³•çº¿è´´å›¾â€è™½ç„¶çœ‹ç€å¥½ï¼Œä½†å…¶å®æ˜¯â€œå‡è±¡â€ã€‚
            // æ³•çº¿è´´å›¾æ˜¯ RGB é¢œè‰²ï¼Œå®ƒçœ‹èµ·æ¥æœ‰ç»†èŠ‚ï¼Œæ˜¯å› ä¸ºå…‰ç…§è®¡ç®—ã€‚
            // ä½†å¦‚æœæ³Šæ¾ç§¯åˆ†ç®—å‡ºæ¥çš„é«˜åº¦åœº (H) æœ¬èº«å°±æ˜¯å¹³æ»‘çš„ï¼ˆå› ä¸ºæˆ‘ä»¬ä¹‹å‰ä¸ºäº†å»å™ªï¼ŒæŠŠ lambda è®¾å¾—å¤ªå°ï¼Œå¯¼è‡´ä½é¢‘ä¿¡æ¯ä¸¢å¤±ï¼‰ï¼Œ
            // é‚£ä¹ˆ Mesh å°±ä¼šçœ‹èµ·æ¥å¾ˆè‚‰ã€å¾ˆå¹³ã€‚
            
            // ä¿®æ­£ï¼šæˆ‘ä»¬åˆšåˆšæŠŠ lambda æ”¹å¾—å¾ˆå° (minL=0.005)ï¼Œè¿™è™½ç„¶ä¿æŠ¤äº†æ¢¯åº¦ç»†èŠ‚ï¼Œ
            // ä½†ä¹Ÿå¯¼è‡´é«˜åº¦åœºå¾ˆå®¹æ˜“è¢«â€œæ‹‰å¹³â€æˆ–è€…â€œé£˜ç§»â€ã€‚
            // ç‰¹åˆ«æ˜¯åœ¨å¤§é¢ç§¯å¹³å¦åŒºåŸŸï¼Œå¾®å°çš„æ¢¯åº¦è¯¯å·®ä¼šç´¯ç§¯ï¼Œå¯¼è‡´æ•´ä½“å½¢çŠ¶æ‰­æ›²ã€‚
            
            // æ—¢ç„¶ç”¨æˆ·è¯´æ³•çº¿è´´å›¾æ²¡é—®é¢˜ï¼Œé‚£æˆ‘ä»¬å°±åœ¨ Mesh æè´¨ä¸Šåšæ–‡ç« ã€‚
            // æˆ‘ä»¬å¯ä»¥ç›´æ¥æŠŠç”Ÿæˆçš„æ³•çº¿è´´å›¾ (Normal Map) è´´åˆ° Mesh ä¸Šï¼
            // è¿™æ · Mesh å³ä½¿å‡ ä½•å½¢çŠ¶ç¨å¾®å¹³ä¸€ç‚¹ï¼Œé æ³•çº¿è´´å›¾ä¹Ÿèƒ½éª—è¿‡çœ¼ç›ï¼Œçœ‹èµ·æ¥ç»†èŠ‚ä¸°å¯Œã€‚
            
            // ä¸è¿‡ç”¨æˆ·æƒ³è¦çš„æ˜¯â€œ3Dè½¬æ¢â€ï¼Œä¹Ÿå°±æ˜¯å‡ ä½•å½¢çŠ¶å¿…é¡»çœŸå®ã€‚
            // è®©æˆ‘ä»¬å›åˆ° generateModel å‡½æ•°ï¼Œæ£€æŸ¥ geometry çš„ç”Ÿæˆé€»è¾‘ã€‚
            
            document.getElementById('dirLightIntensity').addEventListener('input', (e) => {
                document.getElementById('dirLightVal').textContent = e.target.value;
                if(g_dirLight) g_dirLight.intensity = parseFloat(e.target.value);
            });
            document.getElementById('ambLightIntensity').addEventListener('input', (e) => {
                document.getElementById('ambLightVal').textContent = e.target.value;
                if(g_ambientLight) g_ambientLight.intensity = parseFloat(e.target.value);
            });
            document.getElementById('sceneGamma').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                document.getElementById('gammaVal').textContent = val;
                
                renderer.toneMapping = THREE.LinearToneMapping;
                renderer.toneMappingExposure = 1.0 / val;
            });
            document.getElementById('matShininess').addEventListener('input', (e) => {
                document.getElementById('shininessVal').textContent = e.target.value;
                if(currentMesh && currentMesh.material.shininess !== undefined) {
                    currentMesh.material.shininess = parseFloat(e.target.value);
                }
            });
            
            document.getElementById('resetColorsBtn').addEventListener('click', () => {
                terrainStops = [
                    {p: 0.00, c: "#2f7a86"}, {p: 0.08, c: "#4c7e87"}, {p: 0.17, c: "#6a8289"},
                    {p: 0.25, c: "#7a868b"}, {p: 0.33, c: "#367853"}, {p: 0.42, c: "#537f66"},
                    {p: 0.50, c: "#598d54"}, {p: 0.58, c: "#748f72"}, {p: 0.67, c: "#907c72"},
                    {p: 0.75, c: "#917363"}, {p: 0.83, c: "#916a55"}, {p: 0.92, c: "#916146"},
                    {p: 0.99, c: "#848484"}
                ];
                renderColorStops();
                if(currentMesh) generateModel(); 
            });
            
            document.getElementById('applyColorsBtn').addEventListener('click', () => {
                const container = document.getElementById('colorStopsContainer');
                const rows = container.querySelectorAll('.color-stop-row');
                const newStops = [];
                rows.forEach(row => {
                    const p = parseFloat(row.querySelector('.stop-pos').value);
                    const c = row.querySelector('.stop-color').value;
                    newStops.push({p, c});
                });
                newStops.sort((a,b) => a.p - b.p);
                terrainStops = newStops;
                if(currentMesh) generateModel();
            });
        }
        
        function renderColorStops() {
            const container = document.getElementById('colorStopsContainer');
            container.innerHTML = '';
            
            terrainStops.forEach((stop, index) => {
                const row = document.createElement('div');
                row.className = 'color-stop-row';
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.gap = '5px';
                
                row.innerHTML = `
                    <input type="number" class="stop-pos" value="${stop.p}" step="0.01" min="0" max="1" style="width:50px; padding:2px; font-size:0.8rem; background:#1e293b; border:1px solid #475569; color:#e2e8f0; border-radius:4px;">
                    <input type="color" class="stop-color" value="${stop.c}" style="border:none; width:30px; height:24px; background:none; cursor:pointer;">
                    <button class="btn-del" style="background:none; border:none; color:#ef4444; cursor:pointer; font-weight:bold;">Ã—</button>
                `;
                
                row.querySelector('.btn-del').addEventListener('click', () => {
                    row.remove();
                });
                
                container.appendChild(row);
            });
            
            const addBtn = document.createElement('button');
            addBtn.textContent = '+ æ·»åŠ èŠ‚ç‚¹';
            addBtn.style.cssText = 'background:none; border:1px dashed #475569; color:#94a3b8; width:100%; padding:4px; font-size:0.8rem; cursor:pointer; border-radius:4px; margin-top:5px;';
            addBtn.addEventListener('click', () => {
                const row = document.createElement('div');
                row.className = 'color-stop-row';
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.gap = '5px';
                row.innerHTML = `
                    <input type="number" class="stop-pos" value="0.5" step="0.01" min="0" max="1" style="width:50px; padding:2px; font-size:0.8rem; background:#1e293b; border:1px solid #475569; color:#e2e8f0; border-radius:4px;">
                    <input type="color" class="stop-color" value="#ffffff" style="border:none; width:30px; height:24px; background:none; cursor:pointer;">
                    <button class="btn-del" style="background:none; border:none; color:#ef4444; cursor:pointer; font-weight:bold;">Ã—</button>
                `;
                row.querySelector('.btn-del').addEventListener('click', () => row.remove());
                container.insertBefore(row, addBtn);
            });
            container.appendChild(addBtn);
        }

        async function optimizeMesh() {
            generateModel();
        }

        init();
    </script>
</body>
</html>
